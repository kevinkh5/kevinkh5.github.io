---
title: '[Network] 정보처리기사 서브네팅(Subnetting)문제 풀이'
author: baduk
date: 2024-07-16 12:18:00 +0900
categories: [CS, 네트워크]
tags: ['네트워크','정보처리기사']
published : true
---

## 문제1
192.168.1.0/24 네트워크를 FLSM(Fixed Length Subnet Mask) 방식을 이용하여 3개의 Subnet으로  나누었을 때, 두 번째 네트워크의 브로드캐스트 IP주소를 10진수 방식으로 쓰시오.

### 풀이

`/24`는 CIDR(Classless Inter-Domain Routing)표기법으로 서브넷 마스크가 4바이트(1비트X8개X4개) 왼쪽부터 1이 24개(3덩어리) 0이 8개(마지막 한덩어리)라는 뜻으로, 서브네팅시 뒤에 8개(=4번째 덩어리)의 0을 이용할 수 있다는 뜻이다. (여기서 1은 네트워크 부분, 0은 호스트 부분)

즉, 4번째 덩어리는 192.168.1.0 부분에서 맨 마지막 0을 뜻하며, 이 부분을 서브네팅시 이용할 수 있으며, 앞에 192.168.1은 서브네팅시 바뀌지 않고 고정된다.

문제에서 3개의 Subnet으로 나누었을 때의 주소를 구하라고 했으므로, 최소 3개의 서브넷을 나누기 위해서는 8개의 0 중에 두 개의 비트를 이용해야 한다.

그 이유는 두 개의 비트는 2의 2제곱 개, 즉 최소 4개 만큼 수를 표현할 수 있기 때문이다.(ex. 00,01,10,11)

따라서 8개 비트중 2개를 나누는데 사용하였으니, 나머지 6개 비트를 가지고 1번째 네트워크부터 ~ 4번째 네트워크까지 FLSM방식, 즉 똑같은 크기로 나누어 표현하자면 아래와 같다.

```
1번째 네트워크 : 0~63 (00)<네트워크를 나누기 위한 2개의 비트>+(000000~111111)<나머지 6개 비트>
2번째 네트워크 : 64~127 (01)+(000000~111111)
3번째 네트워크 : 128~191 (10)+(000000~111111)
4번째 네트워크 : 192~255 (11)+(000000~111111)
```
각 네트워크의 맨 처음은 `네트워크 주소`이고 마지막 주소는 `브로드캐스트 주소`이다.

따라서 두 번째 네트워크의 브로드캐스트 주소는 192.168.1.0에서 맨 오른쪽 0에 127이 들어가서 `192.168.1.127`이 된다.

답:`192.168.1.127`

## 문제2
IPv4 주소체계 기반의 어떤 네트워크상에서 두 컴퓨터 A, B가 각각 192.168.0.1과 192.168.0.65의 주소를 사용할 때, 이 두 컴퓨터가 서로 다른 서브넷(Subnet)상에 존재하기 위해 사용해야 하는 서브넷 마스크로 가장 옳은 것은? (범위는 64)

### 풀이

범위는 64이므로, A는 0~63, B는 64~ 127 범위의 서브넷상에 존재한다고 볼 수 있다. IP 주소가 192로 시작하면 C Class로 기본 서브넷 마스크는 255.255.255.0으고, 맨 뒤 0을 가지고 서브네팅을 하는데,

0~63을 이진수로 바꾸면, 000000~111111 로 표현할 수 있다. 즉, 0~63의 범위를 표현하기 위해 서브네팅시 사용되는 8개의 비트중 범위를 표현하는데 6비트를 사용했으므로, 나머지 2개의 비트는 네트워크 아이디가 되어가지고, 서브넷을 2의 2제곱만큼 나누는데 사용된것으로 볼 수 있다.

즉, 아래를 보면, 마지막 8개 비트중 맨 왼쪽 2개의 비트까지(1인 부분) 서브넷 마스크를 구하면된다.

`11111111 11111111 11111111 11`000000

따라서 서브넷 마스크는 255.255.255.0에서 0부분에 11000000을 10진수로 바꿔서, 128+64 = 192를
넣으면 구할 수 있다.

답:`255.255.255.192`


## 문제3
130.168.16.0/20을 FLSM방식을 이용해서 17개 서브넷으로 나누고, 10번째 서브넷의 브로드 캐스트 IP를 구하시오.


### 풀이
"/20"은 32개의 비트 중 왼쪽 부터 20개의 비트는 고정비트로 두고, 나머지 12개의 비트를 가지고 서브넷을 나눌 수 있다는 의미다.

위 문제에서는 17개로 나누라고 했으니 17개를 나누기 위해서는 이를 구분하기 위한 최소 5개의 비트가 필요할 것이다. (5개의 비트는 2^5만큼으로 나눌 수 있으므로)

그럼 고정비트를 제외한 나머지 12개의 비트 중 맨 왼쪽부터 5개 비트는 서브넷을 나누는데 사용되고, 나머지 7개 비트는 범위가 될 것이다.

130.168.16.0을 보면 3번째 옥텟이 16이다. 따라서 3번째 옥텟을 이진수 형태의 비트로 표현하자면 아래와 같다.

0 0 0 1 0 0 0 0

모든 옥텟을 /로 끊어서 붙이면 아래와 같이 표현해볼 수 있는데, 위에서 "/20"이라고 했으므로,

`1번째 옥텟(8개비트) / 2번째 옥텟(8개비트) / 0 0 0 1` 0 0 0 0 / 0 0 0 0 0 0 0 0

위와 같이 드래그된 부분 즉, 1번째 옥텟(8개비트) + 2번째 옥텟(8개비트) 하고, 3번째 옥텟에서 4번째(4개비트)까지 총 20개 비트가 고정된다.

그리고 나머지 부분으로 서브넷을 17개로 나눌때 5개의 비트로 나누는데 아래와 같이 나눠질 것이다.

- 첫번째 서브넷:
`1번째 옥텟 / 2번째 옥텟 / 0 0 0 1` 0 0 0 0 / 0 0 0 0 0 0 0 0

- 두번째 서브넷:
`1번째 옥텟 / 2번째 옥텟 / 0 0 0 1` 0 0 0 0 / 1 0 0 0 0 0 0 0

- 세번째 서브넷:
`1번째 옥텟 / 2번째 옥텟 / 0 0 0 1` 0 0 0 1 / 0 0 0 0 0 0 0 0

- 네번째 서브넷:
`1번째 옥텟 / 2번째 옥텟 / 0 0 0 1` 0 0 0 1 / 1 0 0 0 0 0 0 0

....(생략)

이렇게 쭉 구하면, 열번째 서브넷은 아래와 같을 것이다. 

- 열번째 서브넷:
`1번째 옥텟 / 2번째 옥텟 / 0 0 0 1` 0 1 0 0 / 1 0 0 0 0 0 0 0

그리고 문제에서 열번째 서브넷의 브로드 캐스트 IP를 구하라고 했으니 10번째 서브넷의 맨 마지막 주소를 구하면 아래와 같을 것이다.

- 열번째 서브넷의 브로드캐스트IP주소:
`1번째 옥텟 / 2번째 옥텟 / 0 0 0 1` 0 1 0 0 / 1 1 1 1 1 1 1 1

5개의 비트로 서브넷을 나눴고, 나머지 7개의 비트로 범위를 표현했으니, 범위의 맨 끝은 위와같이 표현될 것이다.

따라서 답은 1번째,2번째 옥텟은 그대로 써주고, 3번째 옥텟 이진수(00010100)를 십진수로 바꾸면 20, 4번째 옥텟 이진수(11111111)을 십진수로 바꾸면 255다.

답:`130.168.20.255`

## 참고!
- 서브넷 개수는 -2 안해야 한다.(보통 문제에서 나올리는 없겠지만 IP Subnet-zero적용 안한다라고 하면 -2 해야된다.)
- 그러나 서브넷을 덩어리로 나눴을 때, 그 덩어리 안에 있는 사용할 수 있는 호스트 개수는 반드시 -2 해야 한다. 네트워크 주소와 브로드캐스트 주소는 사용할 수 없는 호스트 주소로 각각을 한개씩 빼야 하기 때문이다.

## 문제4
IPv4의 C클래스 네트워크를 26개의 서브넷으로 나누고, 각 서브넷에는 4~5개의 호스트를 연결하려고 한다. 이러한 서브넷을 구성하기 위한 서브넷 마스크 값은?

### 풀이
네트워크를 26개의 서브넷으로 나누기 위해 8개의 비트중 5개의 비트를 가지고 네트워크 아이디로 사용해야 하다. C클래스는 기본적으로 서브넷마스크가 255.255.255.0 인데, 네번째 옥텟에서 8개 비트중 5개의 비트는 네트워크 아이디로 사용하므로 1로 바꿔주면, 아래와 같다

11111000

따라서 이진수 11111000 을 십진수로 바꾸면 248이 되고, 서브넷 마스크는 255.255.255.248이 된다.
답:`255.255.255.248`


## 문제5
현재 IP 주소가 192.168.1.132이고, 서브넷 마스크가 255.255.255.192일때, 네트워크 주소를 구하고, 해당 네트워크의 네트워크 주소와 브로드캐스트 주소를 제외한 사용가능한 호스트의 수를 구하시오.

### 풀이
현재 IP 주소를 보면 192로 시작하는 것을 볼 수 있는데, 이는 C 클래스 임을 뜻한다. C 클래스는 기본적으로 255.255.255.0의 서브넷 마스크를 가진다.

여기서는 서브넷 마스크가 255.255.255.192라고 했는데, 이를 이진수로 표현하자면 아래와 같다.

11111111 11111111 11111111 11111111 11000000

기본적인 C 클래스의 서브넷 마스크와의 차이가 있는데 그것은 바로 마지막 옥텟에 왼쪽에 두개 비트가 1로 되어있다.

즉, 두개의 비트를 네트워크 ID로 사용하고 있다는 뜻으로, 서브넷이 총 4개로 나뉘어지고, 나머지 0으로 되어있는 6개의 비트를 가지고 호스트를 나눈다고 이해할 수 있다.

대략 첫번째 서브넷부터 네번째 서브넷까지 그것의 마지막 옥텟을 쭉 구해보면 아래와 같다.

첫번째 서브넷의 마지막 옥텟: 00/000000 ~ 00/111111 (0 ~ 63)

두번째 서브넷의 마지막 옥텟: 01/000000 ~ 01/111111 (64 ~ 127)

세번째 서브넷의 마지막 옥텟: 10/000000 ~ 10/111111 (128 ~ 191)

네번째 서브넷의 마지막 옥텟: 11/000000 ~ 11/111111 (192 ~ 255)


그리고 문제에서 현재 IP 주소가 192.168.1.132라고 했는데, 현재 IP 주소의 마지막 옥텟이 132이므로 세번째 서브넷에 속한다고 이해할 수 있다. 따라서 세번째 서브넷에 네트워크 주소는 192이므로 현재 IP 주소의 네트워크 주소는 192.168.1.192다.

그리고 호스트 개수는 0~63까지 64개 인것을 볼 수 있는데, 네트워크 주소와 브로드 캐스트를 제외한 사용가능한 호스트 수는 62개다.

답: `네트워크주소 = 192.168.1.192, 사용가능한 호스트 수 = 62`