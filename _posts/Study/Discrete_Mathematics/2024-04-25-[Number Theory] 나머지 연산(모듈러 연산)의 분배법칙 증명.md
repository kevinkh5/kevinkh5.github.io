---
title: "[Number Theory] 나머지 연산(모듈러 연산)의 분배법칙 증명"
author: baduk
date: 2024-04-25 09:52:00 +0900
categories: [Study, Discrete Mathematics]
tags: [Discrete Mathematics]
use_math: true
---
## (A + B) % C = (A % C) + (B % C) 이거 맞을까?
땡! 틀렸다. 누군가 식을 이렇게 올린 것을 본듯 하다. 하지만 모듈러 연산은 이런식의 분배법칙이 성립하지 않는다. 아래와 같이 반례가 있기 때문이다.

```python
13%3 = 1 # (A + B) % C
8%3 + 5%3 = 2+2 = 4 # (A % C) + (B % C)
```
따라서 `(A+B)%C` 는  `A%C + B%C`라고 일반화 할 수 없다.

### 나머지 연산에서의 분배법칙은 아래와 같은 식에서 성립한다.
```
(A + B) % C = ((A % C) + (B % C)) % C
(A * B) % C = ((A % C) * (B % C)) % C
(A - B) % C = ((A % C) - (B % C)) % C
```

그럼 아래와 같이 나누기가 들어간 식에 대해서는 위와 같은 식 처럼 분배법칙이 성립할까?
```
(A/B)%C = ((A%C)/(B%C))%C
```
No. 성립하지 않는다. 이 또한 반례가 있다.

```python
print((10/3)%5) # 결과: 3/10 (3.333..)
print(((10%5)/(3%5))%5) # 결과: (0/3)%5 => 0
```
따라서 `(A/B)%C = ((A%C)/(B%C))%C` 이 식도 성립하지 않음을 알 수 있다. 그렇다면 조합을 구할 때 아래와 같은 식을 사용하는데,

$ \frac{n!}{r!(n-r)!} $

위 식에 대해 모듈러 연산을 하려면 어떻게 해야 할까? 

보통 팩토리얼 계산은 수가 매우 크게 나올 가능성이 높아서, 코딩할 때 자칫 오버플로우가 발생할 수 있다. 분배법칙이 나누기가 들어간 식에서도 적용이 되면 제때 나머지 연산 적용시켜서 수를 작게 만들어 오버플로우를 막을 수 있는데, 나눗셈에 대해서는 모듈러 연산의 분배법칙을 적용 시킬 수 없다. 이렇게 나누기가 들어간 큰 수를 연산할 때 어떻게하면 오버플로우를 막으면서 모듈러 연산을 적용할 수 있을까?

이 때는 `페르마 소정리`를 통해서 해결해야 한다. (이 게시글에서는 분배법칙 증명 만으로도 글이 길어서, 페르마 소정리에 대한 설명은 따로 정리해서 올리겠다.)

페르마의 소정리 이용하는 문제를 풀어보고 싶다면 아래 링크 클릭!

[백준 11401번 문제](https://www.acmicpc.net/problem/11401)

- 이제 위 내용들을 정리하자면 아래와 같다.

```
(A + B) % C = (A % C) + (B % C) (틀림🙅‍♂️)
(A + B) % C = ((A % C) + (B % C)) % C (맞음🙆‍♂️)
(A - B) % C = ((A % C) - (B % C)) % C (맞음🙆‍♂️)
(A * B) % C = ((A % C) * (B % C)) % C (맞음🙆‍♂️)
(A / B) % C = ((A % C) / (B % C)) % C (틀림🙅‍♂️) => 페르마 소정리 쓰기!
```

자. 지금까지 틀린것은 반례를 통해 틀렸다고 증명했다. 이제 아래에서는 맞는 것은 왜 맞는지를 하나씩 증명해보겠다.


## (A+B)%C = ((A%C)+(B%C))%C 증명
위 식에 대한 증명은 좌변 수식`(A+B)%C` 따로, 우변 수식`((A%C)+(B%C))%C` 따로 쪼개서 하나씩 풀어나가면서 진행하겠다.

## 일단 왼쪽식 (A+B)%C 을 보자.
먼저 치환할 때 사용할 변수 A,B를 아래와 같이 두겠다.

A = q1*C + r1
`(여기서 r1은 A를 C로 나눈 나머지로 C보다는 작을 수 밖에 없다 따라서, 0<=r1<C)`

B = q2*C + r2
`(r2도 마찬가지로, 0<=r2<C)`

(여기서 q1은 A를 C로 나누었을 때의 몫이고, r1은 A를 C로 나누었을 때의 나머지(A%C)이다. q2는 B를 C로 나누었을 때의 몫이고, r2는 B를 C로 나누었을 때의 나머지(B%C)다.)

```
아래 처럼 몫과 나머지로 수를 표현한 것임(참고)
A = (A//B)*B + A%B
5 = (5//3)*3 + 5%3
```

그리고 이 A,B 각각을 위 식`(A+B)%C`에 치환하면,

(q1*C + r1 + q2*C + r2)%C = ((q1+q2)C + (r1 + r2))%C

가 된다.

여기서 (r1+r2)의 범위는 0 <= (r1+r2) < 2C 이다. 이 범위를 아래와 같이 두 구간으로 쪼개서 (A+B)%C를 구해보겠다.

- 0 <= (r1+r2) < C
- C <= (r1+r2) < 2C

만약 r1+r2가 C보다 작다면, 즉 0 <= (r1+r2) < C 라면, q1 + q2가 (A+B)를 C로 나누었을때의 몫이 되고, r1+r2는 (A+B)를 C로 나누었을때의 나머지가  될 것이다.
즉, 0 <= (r1+r2) < C이면, (A+B)%C = r1+r2

만약 (r1+r2)의 값의 범위가  C <= (r1+r2) < 2C라면?

r1+r2 = C*r’ + r’’ (0<=r’’<C)로 표현 할 수 있을 것이다. 그럼 
위에서 작성한 ((q1+q2)C + (r1 + r2))%C 이 식에 (r1+r2)부분을 C*r’ + r’’ 이 값으로 치환하면,

((q1+q2)C + ( C*r’ + r’’))%C
=((q1+q2+r’)C + r’’)%C

이 되어서 결국 (A+B)를 C로 나누었을 때의 몫은 q1+q2+r’가 되고, r’’은 (A+B)를 C로 나누었을 때의 나머지가 된다.
따라서 이 때는 (A+B)%C = r’’
즉, C <= (r1+r2) < 2C이면, (A+B)%C = r’’이 된다.

## 이제 오른쪽 식 ((A%C)+(B%C))%C을 보자.

위에서 한 것과 마찬가지로
- A = q1*C + r1 (0<=r1<C)
- B = q2*C + r2 (0<=r2<C)

위 A,B를 각각 아래식에 치환한다.

((A%C)+(B%C))%C
=((q1*C + r1)%C + (q2*C + r2)%C)%C

이렇게 되고,
(q1*C + r1)%C 는 r1, (q2*C + r2)%C는 r2가 될 것이다.

왜냐?

위에서 r1의 범위는 0이상 C미만이라고 했다. 즉 r1 그 자체로 A를 C로 나누었을 때의 나머지가 될 수 있다. 물론 r2 역시 마찬가지로 B를 C로 나누었을 때의 나머지다.

그럼 결국 오른쪽 식 `((A%C)+(B%C))%C` = (r1 + r2)%C가 된다.

만약 (r1+r2)의 값의 범위가 0 <= (r1+r2) < C 라면, 위에서 왼쪽 식에서 구했던것 과 마찬가지로 r1+r2 그대로가 (A+B)를 C로 나누었을 때의 나머지가 된다.
즉, 0 <= (r1+r2) < C이면, (A+B)%C = r1+r2

만약 (r1+r2)의 값의 범위가 C <= (r1+r2) < 2C라면, r1+r2 = C*r’ + r’’ (0<=r’’<C)으로 표현할 수 있고, 따라서 

(r1 + r2)%C
= (C*r’ + r’’)%C

가 되어서 (A+B)를 C로 나눈 나머지는 r’’이 된다.
즉, C <= (r1+r2) < 2C이면, (A+B)%C = r’’

자, 이제 보이는가. 왼쪽 식`(A+B)%C`이나 오른쪽 식`((A%C)+(B%C))%C`이나 치환할 때 사용된 변수 (r1+r2)의 범위만 같다면 두식에서 모두 아래와 같이 같은 나머지 값이 도출된다.

- 0 <= (r1+r2) < C이면, (A+B)%C = r1+r2
- C <= (r1+r2) < 2C이면, (A+B)%C = r’’

따라서 (A+B)%C = ((A%C)+(B%C))%C임이 증명되었다!

사실 위 증명과 같은 방법으로 `(A - B) % C = ((A % C) - (B % C)) % C` 이 식과 `(A * B) % C = ((A % C) * (B % C)) % C`이 식을 증명할 수 있다.

## (A - B) % C = ((A % C) - (B % C)) % C 증명

- A = q1*C + r1 (0<=r1<C)
- B = q2*C + r2 (0<=r2<C)

A,B를 각각 좌변`(A - B) % C`에 치환하고, C로 묶어 정리하면 아래와 같다.

((q1 - q2)C + (r1 - r2))%C

이때 (r1 - r2)의 값의 범위는 `|(r1 - r2)| < C`가 된다.
```
왜냐? 간단하게 생각해보면, |(r1 - r2)|이 의미하는 바는 r1과 r2의 간격을 뜻하는데,
만약 이 간격이 최대가 되려면 r1이 최대가 되고 r2가 최소가 되면 될것이다. 
그러면 r1은 최대가 되려면 C에 아주 가까운 수일 것이고, r2가 최소가 되면 0일 것이다.
그럼 |(r1 - r2)|는 최대 C값은 안되고 C보다는 살짝 작은 값이 될 것이다.
따라서 |(r1 - r2)| < C임을 이해할 수 있을 것이다.
```
즉, 다르게 표현 하면, `-C < (r1 - r2) < C` 가 된다.

그럼 이 범위를 음수 범위와 양수 범위로 쪼개면 아래와 같다.

- -C < (r1 - r2) < 0 (음수범위)
- 0 <= (r1 - r2) < C (양수범위)

만약 (r1 - r2)가 음수 범위면 (r1 - r2)에 C를 더해주면 범위는 0 < (r1 - r2 + C) < C가 될 것이다. 즉 따라서 이때 ((q1 - q2)C + (r1 - r2)) 이 식은 `((q1 - q2 - 1)C + (r1 - r2 + C))` 이 식으로 변형시킬 수 있고, (q1 - q2 - 1)은 (A-B)를 C로 나누었을 때의 몫이되고,  r1 - r2 + C는 그 자체로 (A-B)를 C로 나누었을때의 나머지가 될 것이다.

- 즉, -C < (r1 - r2) < 0 (음수범위)이면, `(A - B) % C = r1 - r2 + C`

만약 (r1 - r2)가 양수 범위면? 0 <= (r1 - r2) < C이라고 했으니까, (r1 - r2) 그 자체로 (A - B) % C가 될 것이다.

- 즉, 0 <= (r1 - r2) < C (양수범위)이면, `(A - B) % C = r1 - r2`

자 이제 우변 `((A % C) - (B % C)) % C`을 보자 

위에서

- A = q1*C + r1 (0<=r1<C)
- B = q2*C + r2 (0<=r2<C)

라고 했다. 따라서 `((A % C) - (B % C)) % C`는 `(r1 - r2)%C`가 된다.

여기서도 마차간지로 (r1 - r2)의 범위가 -C < (r1 - r2) < 0 (음수범위)이면, (r1 - r2) % C = r1 - r2 + C가 될 것이다. 왜냐? (r1 - r2)가 위와 같은 음수범위이면 (r1 - r2)에 C를 더해주면 (r1 - r2) + C가 되고, 그 범위는 0 < (r1 - r2) + C < C 가 된다. 그럼 (r1 - r2)를 (r1 - r2 + C) - C로 표현했을 때, 식 `(r1 - r2 + C) - C` 을 C로 나눈 나머지는 (r1 - r2 + C)가 될 것이고 몫은 -1이 될 것이다.

(r1 - r2)의 범위가 0 <= (r1 - r2) < C (양수범위)이면, (r1 - r2) % C = r1 - r2가 될 것이다. (r1 - r2)의 범위가 0 <= (r1 - r2) < C이면, 그 자체로 C보다 작은 값이기 때문에 몫은 그냥 0이 될 것이다.

증명이 끝났다. (r1 - r2)의 범위가 같다면, 같은 나머지연산 결과를 내놓으므로 빼기에 대해서도 모듈러 연산의 분배법칙이 성립한다는 것을 알 수 있다.

## (A * B) % C = ((A % C) * (B % C)) % C 증명

이것도 마찬가지로 아래 식 치환하고, 정리하고, 좌 우변이 같다를 증명하면 된다. 위 증명하는 방법과 거의 똑같기 때문에 설명은 생략하겠다.
- A = q1*C + r1 (0<=r1<C)
- B = q2*C + r2 (0<=r2<C)
