---
title: '[Number Theory] 오일러 피(Euler-Phi)를 완전히 이해하기 위한 디테일한 증명과 파이썬 구현'
author: baduk
date: 2024-03-13 07:38:00 +0900
categories: [Study, Data Structre and Algorithm]
tags: [study, python, problem solving, algorithm]
use_math: true
---

## 오일러 피
오일러 피 함수 P[n]은 n이하의 자연수 중 n과 서로소(공약수가 오직 1만 있는 수)인 양의 정수의 개수를 뜻한다.

예를들어 P[6] 이라고 했을 때, 6이하의 자연수는 1,2,3,4,5,6이 있는데 이 중 6과 서로소 관계에 있는 수는 1,5 로 총 2개다. 따라서 P[6] = 2


## 꼭 기억해야할 용어
소수 = 약수 1과 자기자신밖에 없는 수

소인수 = 어떤 정수를 나눌 수 있는 소수

서로소 = 공약수가 오직 1 하나 뿐인 수

## 오일러 피 공식 유도전 알아야 할 사전지식

오일러 피, 어떻게 공식화할 수 있을까? 

P[6]과 같이 작은 수는 위와 같이 수를 쭉 나열해서 지워서 개수를 구하면 된다. 그럼 P[1000]과 같이 큰 수는 어떻게 구할 수 있을까?

결론부터 말하자면 공식에 적용시켜 풀어야 한다. 수를 나열해서 지워가는 방식으로 풀기에 너무 큰 수 이기 때문이다.

일단 공식을 만들기 위해 우리는 오일러함수의 성질을 하나 알아야 한다. 오일러 함수는 아래와 같이 곱셈함수의 산술적 성질을 가진다. (아래에 p와 q는 소수이다.)

P(p * q) = P(p)*P(q)

왜 그러한지 아래에서 증명해보자.

### 오일러 피 함수는 왜 곰셈함수의 성질을 가질까?

일단 우리는 오일러함수의 곱셈함수 성질을 증명하기 이전에 우리는 소수 값에 대한 오일러 함수 값은 그 소수 값 - 1이라는 사실을 알아야 한다. 왜 소수 값에 대한 오일러 함수 값은 그 소수 값 - 1일까? 소수의 소인수(어떤 정수를 나눌 수 있는 소수)는 자기자신밖에 없기 때문이다. 따라서 그 소수의 서로소(공약수가 오직 1만 있는 수)의 개수는 자기자신을 제외한 나머지다. 즉, 그 개수는 소수 - 1개다.

예시를 하나 들어보자. 11은 소수다. 따라서 P(11) = 11 - 1 = 10 이다. 왜냐하면 11이하의 수 1,2,3,4,5,6,7,8,9,10,11 중 서로소가 아닌 수는 11밖에 없기 때문이다.

자 이제 `소수 값에 대한 오일러 함수 값은 그 소수 값 - 1`<- 이 사실을 기억하고 왜 오일러함수가 곱셈함수의 성질을 가지는지 증명해보자.

#### P(p)*P(q) 구하기
P(p * q) = P(p) * P(q)를 증명하기 위해 먼저 p,q 라는 두 소수를 두겠다. 그리고 먼저 P(p)*P(q) 를 구해보자. p,q는 모두 소수이기 때문에 위에서 설명했듯 P(p) = p - 1 이고 P(q) = q - 1 이다. 따라서 식은 아래와 같다.

```
P(p) * P(q) = (p - 1)*(q - 1) = pq - p - q + 1
```

#### P(p*q)를 구하기
이번엔 P(p*q)를 구해보자. 어떻게 구할 수 있을까? pq는 p의 배수이기도 하고, q의 배수이기도 하다. 따라서 우리는 p * q에서 p의 배수와 q의 배수를 제거하고난 개수를 구하면 답이된다.

그럼 우리는 어떻게 p*q이하의 양의 정수에서 p의 배수의 개수 또는 q의 배수의 개수를 알 수 있을까?

결론부터 말하자면, 아래의 공식을 가지고 구할 수 있다.

`자연수 N 이하의 자연수들 중에서 K의 배수인 수의 개수는 N을 K로 나눈 몫이다.`

즉, 위 말을 아래에 파이썬 코드로 표현해보자면, 아래 파이썬 코드는 늘 True 라는 뜻이다.

`len([K, 2*K, 3*K ...]) == N//k`

그럼 위 식이 왜 성립될까?

먼저 그 이유를 설명하기 이전에 위 식이 진짜 적용이 되는지 시도해 보겠다.

7이하인 자연수 중에서 2의 배수인 수의 개수를 구한다고 해보자.
7이하인 자연수는 1,2,3,4,5,6,7이 있다.

여기서 2의 배수는 2,4,6다. 따라서 7이하인 자연수 중에서 2의 배수의 개수는 총 3개(2,4,6)다.

그럼 7을 2로 나눈 몫은? 3이다.

7이하의 자연수 중 2의 배수의 개수가 7을 2로 나눈 몫과 정말 같다. 실제로 적용한게 잘 나왔다.

그럼 이제 이게 왜 일반화 될 수 있는지 아래에서 증명해보겠다.

예를들어 자연수 N 이하인 자연수들 중에서 K의 배수인 수의 개수를 구하려고한다. N이하의 자연수들 중 K의 배수인 수는 아래와 같이 M개가 있다고 하자.

1*K, 2*K, 3*K, …, M*K

여기서 중요한 것은 M * K와 N의 관계를 아는것이다. 위 수의 나열은 N이하의 자연수를 나타낸 것이다. 즉 M*K는 N과 같을 수도 있고 N보다 작을 수도 있다. 따라서 수학적으로 표현하자면, M * K $\leq$ N 이다. 다르게 표현 하자면, 아래와 같이 표현할 수 있다.

N = M*K + A (0 $\leq$ A $\lt$ K)

그럼 양변을 K로 나누면?

$ {N \over K} = {(M * K + A)\over K} $ 가 되고 $ (M * K + A)\over K $ 를 정리하면  $M + {A\over K}$가 된다. 여기서 A는 위에서 0이상이고 K보다는 작다했으니, ${A\over K}$는 1보다는 작은 수다. 다시 식을 써보면, $ {N \over K} =  M + {A\over K} (0 \leq {A\over K}<1) $가 되고 결국 N을 K로 나눴을 때 몫은 무조건 M이라는 결론이 나온다.

`즉, N을 K로 나눴을 때 몫은 N 이하이면서 K의 배수인 자연수의 개수와 같다는 사실이 증명된다.`

이제 p * q이하의 양의 정수에서 p의 배수의 개수 또는 q의 배수의 개수를 어떻게 구할 수 있는지 알게 되었으니, 다시 돌아와서 P(p*q)를 구해보자.

$ P(p * q) = p*q - {(p * q)\over p} - {(p * q)\over q} $

그럼 위 식처럼 구하면 될까? 땡. 우리는 p의 배수인 수를 제거하고 q의 배수인 수를 제거하면서 중복적으로 제거한 것이 하나 있다. 그것이 바로 p의 배수이기도 하면서 q의 배수이기도 한 p*q라는 수다. 따라서 우리는 이 p * q라는 수를 두번 빼줬으니까 위 식에 +1을 해야 한다.(포함 배제의 원리) 따라서 P(p * q)의 정확한 값은 아래와 같다.

$ P(p * q) = p*q - {(p * q)\over p} - {(p * q)\over q} + 1$

위 식을 한번 더 정리하면 아래와 같다.

```
P(p * q) = p*q - q - p + 1
```

위 식 어디서 많이 본것 같지 않은가? 그렇다. 방금 위에서 구한 P(p) * P(q)와 똑같은 결과다. 즉, ```P(p * q) = P(p) * P(q)```임이 증명된 것이다. (물론 여기서 p,q는 반드시 소수여야 한다는 조건이 있음을 잊지 말아야 한다.)

자 이제 우리는 우리의 최종 목표인 오일러피 공식을 도출하기 위한 사전지식을 갖추게 되었다. 이제 진짜 오일러피 공식을 아래에서 도출해보자.

## 오일러피 공식유도

P(n)을 구하는게 우리의 목표다. 우리는 P(n)을 공식화 해볼 것이다.

먼저 이 n을 소인수 분해했을때 아래와 같다고 해보자.

 $ n = p_1^{a_1} p_2^{a_2} p_3^{a_3} ... p_k^{a_k} $


그럼 P(n)은 아래와 같다.

$ P(n) = P(p_1^{a_1} p_2^{a_2} p_3^{a_3} ... p_k^{a_k}) $

또한 위에서 사전학습한 곱셈함수의 성질에 의해 아래와 같이 표현할 수도 있다.

$ P(n) = P(p_1^{a_1})P(p_2^{a_2})P(p_3^{a_3})...P(p_k^{a_k}) $

아래 수들은 모두 소수의 거듭제곱이다. 즉 소인수가 자기자신밖에 없는 수다.

$ p_1^{a_1}, p_2^{a_2}, p_3^{a_3}, ... p_k^{a_k} $

따라서 $ P(p_1^{a_1}) $ 은 $ p_1^{a_1} $ 에서 $ p_1 $ 의 배수의 개수 즉, $ (p_1^{a_1} / p_1)$ 만큼을 빼서 구할 수 있다. 

결론적으로 우리는 아래와 같다는 것을 알 수 있다.

$ P(p_1^{a_1}) = p_1^{a_1} - p_1^{a_1-1}$

그럼 다시 돌아와서 P(n)을 새롭게 표현해보자면 아래와 같다.

$ P(n) = (p_1^{a_1} - p_1^{a_1-1})(p_2^{a_2} - p_2^{a_2-1})(p_3^{a_3} - p_3^{a_3-1})...(p_k^{a_k} - p_k^{a_k-1})$

위 식에서 $ p_1^{a_1} p_2^{a_2} p_3^{a_3} ... p_k^{a_k} $ 을 빼내어 표현하면 아래와 같다.

$ P(n) = p_1^{a_1} p_2^{a_2} p_3^{a_3} ... p_k^{a_k}(1-{1\over p_1})(1-{1\over p_2})...(1-{1\over p_k})$

위에서  $ n = p_1^{a_1} p_2^{a_2} p_3^{a_3} ... p_k^{a_k} $ 라고 했다. 따라서 최종적으로 정리하자면 아래와 같다.

$ P(n) = n (1-{1\over p_1})(1-{1\over p_2})...(1-{1\over p_k})$

공식유도 끝났다. 아래 이것이 공식이다.

$ P(n) = n (1-{1\over p_1})(1-{1\over p_2})...(1-{1\over p_k})$

자, 이제 우리는 어떤 수 n에 대해서 P(n)을 구할 공식을 발견했다. 우리는 간단하게 이제 어떤 수 n을 소인수 분해하여 그 수의 소인수를 가지고 위 공식에 대입해서 P(n)을 쉽게 구할 수 있게 되었다.

## 오일러 피 파이썬 구현
이제 위에서 구한 공식을 가지고 파이썬 코드로 구현할 일만 남았다.

일단 코드로 구현하기 이전에 사람의 입장으로서 오일러피 공식을 사용하여 특정 수에 대한 오일러 함수값을 구해보자.

예를들어 오일러피 함수가 P일 때,  P(1000)을 구한다고 해보자. 오일러 피 공식에 적용시키려면 1000의 소인수를 구해야 한다.
만약 사람이 직접 오일로 피 공식에 적용시켜 구한다면 어떻게 할까?

1000을 소인수분해하면 $ 1000 = 2^3 * 5^3 $ 이니까 2와 5가 1000의 소인수고 오일러 피 공식에 적용시켜 구하자면 $ 1000(1- {1\over2})(1- {1\over5}) = 400$
이와 같이 P(1000)의 값을 구할 수 있을 것이다.

그렇다면 이걸 코드로 구현해서 동작 시키려면 어떻게 해야할까?

코드에서 크게 두 로직을 구성해야 할 것이다.

1.소인수 구하는 로직 - 오일러피 공식을 적용시켜 구하려면 구하고자 하는 수의 소인수를 먼저 알아내야 한다.

2.오일러 피 공식 연산 로직 - 소인수를 찾아냈다면, 그 소인수를 가지고 오일러 피 공식으로 연산시켜가면서 업데이트 한다.


이제 아래에서 오일러 피 함수가 P일때, P(1000)을 오일러피를 적용시켜 코딩해서 구해보자.

### 소인수 찾는 반복범위 설정
P(1000)을 구하기 위해서는 먼저 1000의 소인수를 알아내는 작업부터 진행해야 할 것이다. 그렇다면 소인수를 알아내기 위해 2부터 999까지 하나씩 반복하면서 소인수인지 체크해보면 될까? 아니다. 우리는 2부터 31까지만 소인수 인지 체크해보면 된다. 왜냐? 32부터는 자신의 제곱이 1000을 넘기기때문이다. 32 * 31을 했을때는 992로 1000을 안넘기니까 체크해봐야 할 것 같은데 무슨소리냐? 라고 할 수도 있는데, 잘 생각해보면 32 * 31은 32하기 이전 루프에서 31이 소인수인지 아닌지 판단할때 이미 체크를 했다라는 거다.

결과적으로 31이 소인수가 아니었기에, 32 * 31은 소인수일리도 없을 뿐더러 소인수인지 확인해 볼 필요도 없다. 왜냐? 31에 대해서 소인수 인지 체크할 때 이미 해본거나 다름없으니까. 또한 32 * 30, 32 * 29, 32 * 28, 32 * 27… 도 마찬가지로 해본거나 마찬가지다. 반복문안에서 어떤 수 A에 대해서 소인수인지 아닌지 판단할때는 A랑 같거나 큰수를 곱해보면서 소인수인지 확인을 해야 중복연산을 하지 않게 된다. A에 A보다 작은 수를 곱해서 소인수인지 아닌지를 확인하는 것은 중복연산을 또 하는 것이다.

이 부분에 대해 이해를 돕기위해 추가적인 설명을하자면, 만약 2부터 제곱근까지 다 확인했는데 소인수가 없었다? 그럼 제곱근 이후는 체크해볼 필요도 없이 소인수가 없을 것이다. 제곱근 이후로 소인수가 있다면 앞에 제곱근 이전의 수에서 이미 소인수가 발견됐을 테니까.

따라서 이 부분도 에라토스테네스의 체를 구현할 때 처럼, 소인수를 찾으려고 반복할 때의 범위는 구하고자 하는 수의 제곱근까지만 체크하면 된다.

### 오일러피 공식연산
이제 위에서 정한 반복 범위하에서 오일러피 공식연산을 적용시키면 된다. 위에서 들었던 예시 P(1000)을 구한다고 했을때, 처음에 2부터 시작하면서 등장하는 소인수는 2가 될 것이다. 그리고 소인수를 발견했기 때문에 이를 적용시켜서 result = result - result // i 로 즉, 오일러 피 공식연산으로 result를 업데이트 한다. 그럼 우리는 1000이라는 수의 소인수 중 하나인 2를 연산처리했으므로 2이외에 다른 소인수가 있는지를 찾아야 한다. 그 방법으로는 1000을 2로 나누어 떨어지지 않을때까지 그 몫을 계속 구하고, 그 나온 수에 대해서 다시 또 다른 소인수를 찾아나가면 된다. 우리는 2로 나누어 떨어지지 않을 때 까지 그 몫을 구해서 업데이트 했기 때문에, 최종 업데이트 된 수는 2를 소인수로 가지지 않는 어떤수가 되어있을 것이다. 우리는 또 다시 그 수의 소인수를 찾아나가면 된다.

2로 나누어 떨어지지 않을 때까지 몫을 계속구해서 나온 최종 수는 125가 나올 것이다. 우리는 이제 이 125를 가지고 그 다음 루프에서의 i 즉, 3부터 소인수인지 체크를 해나가면서 찾아나가면 된다. 그러다가 5는 125의 소인수임이 판정되는데, 처음에 했던 과정에서 거쳤던것처럼 소인수 5를 가지고 오일러피 연산으로 result를 업데이트하고 다시 125인 n을 5로 나누어떨어지지 않을 때까지 반복해서 5로나눈 몫으로 업데이트한다. 이후 과정도 마찬가지로 앞에서 했던 것처럼 소인수인지 체크해가면서 반복해나가고 소인수를 발견하면 오일러피 공식 연산처리로 업데이트 하면된다.

소인수를 찾다가 결과적으로 n이 1이 되면 더이상 조건을 만족하는 것이 없다가 result를 반환하게 되면서 P(1000) 값을 리턴할 것이다. n이 1이 되었다는 뜻은 더이상 소인수분해할게 없다는 뜻이기도 하니까.

만약 n에 1이 아닌 다른 소수가 남아있다면? 그 소수를 가지고 마지막에 한번 더 오일러피 연산처리를 하면된다.

만약 애초에 P(11),P(17)과 같이 소수가 들어오는 경우에는 반복문안에서 진행되는 것 없이 해당 조건문안에서 오일러 피 공식으로 연산처리 한번하고 끝날것이다.

## 오일러 피 구현 파이썬 코드
```python
def euler_phi(n):
    result = n
    for i in range(2, int(n ** 0.5) + 1):  # 반복은 제곱근까지만 진행
        if n % i == 0:  # i가 n의 소인수인지 체크
            result = result - result // i  # 오일러 피 연산으로 업데이트
            while n % i == 0:  # 또 다른 소인수 찾기 위해 찾은 소인수로 나누어 떨어지지 않을때까지 반복
                n = n // i
    if n > 1:  # n에 남은 소수에 대해서 마지막으로 한번더 오일러 피 연산으로 업데이트로 마무리
        result = result - result // n
    return result
```