---
title: '[Sliding-Window] 백준 21921번 블로그 Python풀이'
author: baduk
date: 2024-03-14 10:21:00 +0900
categories: [Study, Data Structre and Algorithm]
tags: [study, python, problem solving, algorithm]
use_math: true
---
## 문제소개
특정 구간x와 정수를 포함한 1차원 배열이 주어진다. 특정 구간 x에 대한 가장 큰 구간합과 그 개수를 구하라.

## 문제접근
이 문제를 단순 브루트포스식으로 해결하려고 하면 시간복잡도가 구간의 크기 곱하기 배열의 크기가 될 것이다.

문제에서 주어진 제한 사항을 보면 배열의 크기와 구간의 크기 모두 최대 25만이다. 즉, 시간복잡도는 25만의 제곱으로 브루트포스식으로는 시간제한에걸려 풀 수 없다.

이 문제는 슬라이딩 윈도우 알고리즘을 가지고 접근해야한다.

## 슬라이딩 윈도우?
슬라이딩 윈도우 알고리즘을 간단하게 설명하자면, 특정 구간합을 모두 구해야하는 문제에서 사용될 수 있는 알고리즘으로 굉장히 효율적인 시간복잡도를 보인다.

이 문제에서 브루트포스 식으로 접근했을 때는 시간복잡도가 $ O(N^2)$ 이었지만 슬라이딩 윈도우는 $ O(N)$ 으로 해결 가능하다.

원리는 간단하다. 구간하나하나 이동할때마다 계속 Sum을 하는 방식인 브루트포스방식과 다르게 슬라이딩 윈도우 알고리즘은 구간을 하나 옮기면 맨앞에 인덱스에 위치한 값을 빼주고, 새로 이동할 인덱스의 값을 더해주면서 진행한다.

즉 한번의 루프에서 모든 구간을 다 더하는 작업을 하지 않고 앞은 빼고 뒤는 더하는 두 가지 작업만 한다. 따라서 굉장히 효율적이라고 할 수 있다.

## 문제풀이
이 문제에도 똑같이 적용해서 풀면 된다.

먼저 처음 구간의 합으로 초기화하고, 그 후 반복문을 통해 구간 한 칸씩 이동해가면서 연산을 진행하면 된다. 반복문 안에서는 처음에 0에 위치한 인덱스의 값을 지우고 x에 위치한 인덱스의 값을 더할 것이다. 그리고 마지막에 더해줄 인덱스의 값이 배열의 끝까지 왔으면 반복문을 종료한다.

반복문이 진행되는 동안 구간의 합이 최대인지 또는 최대값과 같은지를 체크해가면서 진행하면 된다. 이 부분은 간단하게 로직으로 구성할 수 있으므로 자세한 설명은 생략하겠다.

## 제출코드

```python
import sys
input = sys.stdin.readline

n,x = map(int,input().split())
arr = list(map(int,input().split()))
cnt = 1

cur = sum(arr[0:x])
max = cur

for i in range(n-x):
    cur -= arr[i]
    cur += arr[i+x]
    if cur > max:
        max = cur
        cnt = 1
    elif cur == max:
        cnt += 1

if max == 0:
    print("SAD")
else:
    print(max)
    print(cnt)
```