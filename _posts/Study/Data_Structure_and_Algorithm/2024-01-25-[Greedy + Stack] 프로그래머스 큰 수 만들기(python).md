---
title: '[Greedy + Stack] 프로그래머스 큰 수 만들기(python)'
author: baduk
date: 2024-01-25 14:21:00 +0900
categories: [Study, Data Structre and Algorithm]
tags: [study, python, problem solving, algorithm]
use_math: true
---
출처:<https://school.programmers.co.kr/learn/courses/30/lessons/42883>

## 문제 간단소개
어떤 숫자에서 K개 만큼 수를 제거했을 때, 나올 수 있는 최대값 구하기.

## 문제접근 및 아이디어
일단 최대값을 만들기 위해서 가능한 앞에 있는 숫자가 큰 숫자가 오도록 해야한다는 사실을 발견해야 한다. K개 만큼 뺀다고 했을때, K개 만큼 빼는 행위를 어떻게 하든간에 그 자리수는 모두 일정하기 때문이다.

나는 처음에 문제를 풀때 앞에 지울 수 있는 범위를 두고, 최대값을 남기도록 지우고, 그 다음 다시 그 최대값을 앞에 두고 뒤에서 부터 다시 최대값만 남기도록 지우고, 계속 지우다가 K=0이 되면 중지하는 식으로 코드를 작성하였다.

문제는 이런식으로 코드를 작성하여 제출했을때 테스트8과 테스트10에 시간초과가 났고, 코드가 상당히 복잡하고 까다로워진다. 그 이유는 특정 범위를 구할 때 리스트 슬라이싱도 해야하고, Max값의 인덱스를 구하고 또 그 값을 가지고 슬라이싱 해야하기 때문에 코드작성이 상당히 까다로워진다. 일단 코드작성이 까다로워지는 순간 디버깅에서 무조건 시간을 많이 잡아 먹히기 때문에 이러한 방법으로 문제를 해결하려고 시도하는 것은 피해야 할 것이다.

이 문제는 스택을 활용하면 시간복잡도 문제도 해결할 수 있고, 좀 더 간단하게 풀릴 수 있다. 아래에서 설명해보겠다.

## 풀이핵심은 스택
일단 number에서 맨 앞에 숫자를 가지고, 스택에 넣는다. 그리고 number에서 두번째 수를 가지고 와서 스택 꼭대기에 있는 수와 비교한다. 스택에 있는 수 보다 크다면, 스택에 있는 수를 팝시키고 K에서 1빼준다. 그리고 나서도 스택에 꼭대기에 있는 수가 더 작다면 또 팝 시킨다. 더 작은 수가 없다면 스택에 그 수를 넣는다. 스택에 있는 수 보다 넣어줄 값이 작다면 그냥 스택에 넣어준다. (스택은 늘 하노이탑 처럼, 큰 수가 맨 아래에 깔려있고, 그 위로 작은수들이 위로 올려져 있을 것이다.) 또한 K가 0이 되어 더 이상 숫자를 지울 수 없는 상태가 되면, 나머지 수들을 스택에 그냥 넣어준다.

처음에 제출했던 코드는 아래와 같다.

```python
def solution(number, k):
    stack = []
    for i in number:
        while stack and k > 0:
            if stack[-1] < i:
                stack.pop()
                k -= 1
            else:
                break
        stack.append(i)
    return ''.join(stack)
```
결과적으로 위 코드는 한 테스트 케이스에 대해서 틀렸다. 왜냐하면 number='91'이고 k=1일 때, 9가 처음에 스택에 들어가는데 1은 9보다 작으므로 스택에 그대로 쌓여서 결과적으로 k에 남아있는 1을 지우지 않고 '91'을 그대로 출력하기 때문이다.

즉 이 케이스를 통해서 for 문안에서 k를 0으로 만들어주는것을 보장하지 못한다는 사실을 깨달았고, 아래와 같이 코드를 다시 작성해서 제출하여 성공판정을 받았다.

## 제출코드
```python
def solution(number, k):
    stack = []
    for i in number:
        while stack and k > 0:
            if stack[-1] < i:
                stack.pop()
                k -= 1
            else:
                break
        stack.append(i)
    # 추가된 부분
    if k>0:
        for i in range(k):
            stack.pop()
    return ''.join(stack)
```
이 문제는 그리디 문제이지만, 그리디 문제는 정말 다양하게 출제되어서 특정한 풀이법이라는게 존재하지 않는 것 같다. 다양한 그리디 문제를 접하면서 문제해결력을 기르는데 집중해야 겠다.