---
title: '[Greedy] 백준 1449번 수리공 항승 Python풀이'
author: baduk
date: 2024-02-22 11:04:00 +0900
categories: [Study, Data Structre and Algorithm]
tags: [study, python, problem solving, algorithm]
use_math: true
---
출처:
<https://www.acmicpc.net/problem/1449>

## 문제 간단소개
수도 파이프 몇몇 위치에 구멍이 있다. 이 구멍을 테이프로 붙여서 막아야한다. 구멍난 곳의 위치와 테이프 길이가 주어졌을 때 파이프 구멍을 테이프로 막기위한 필요한 테이프의 최소개수를 구하라.

## 문제 접근
최소한의 테이프를 붙여서 구멍을 모두 막는 방법을 떠올려야 한다는 점을 봤을 때, 그리디 문제라는 것을 알 수 있다.

아래에서 예시와 함께 접근해 보면서, 코드 구현을 구체화해보겠다.

예를들어 파이프에 구멍난 위치가 [1, 2, 100, 101]이고 테이프의 길이가 2라면, 먼저 1위치에서 테이프를 붙인다고 할 때 최대 2위치까지 테이프를 붙여 두 구멍을 막을 수 있을 것이다.

위 예시에서 2위치에 구멍이 있으므로, 1위치와 2위치를 한 테이프로 막는다. 그리고 나서 2위치에서 테이프를 붙인다고 할 때 최대 3위치까지 테이프를 붙여 두 구멍을 막을 수 있을 것이다. 하지만 위 예시에서 3위치에는 구멍이 없으므로 넘어간다.

그렇다면 1위치와 2위치는 일단 구멍에 테이프를 붙여 막았으니, 100위치를 보자. 100위치에서는 테이프를 붙인다고 할 때 최대 101위치까지 테이프를 붙여 두 구멍을 막을 수 있을 것이다. 위 예시에서 101위치에 구멍이 존재하므로 테이프를 붙여막는다.

이렇게 테이프 두개를 사용하여 모든 구멍을 막았다.

이제 위 로직을 코드로 구현해보자면 아래와 같다.

## 제출 코드 및 코드 설명

```python
import sys
input = sys.stdin.readline

n,l = map(int,input().split())
pos = list(map(int,input().split()))
pos.sort()

now = 0
cnt = 0
for p in pos:
    if p > now:
        now = p + l - 1
        cnt += 1
print(cnt)
```
먼저 파이프 구멍의 위치를 오름차순으로 정렬한다. 작은 위치부터 순서대로 테이프를 붙여나가야하기 때문이다. 테이프를 붙였을 때 최대로 붙일 수 있는데 까지의 거리를 0으로 초기화 한다.(변수이름은 now로 선언하였다)

그리고 구멍의 위치를 for문으로 하나씩 가져오면서 최대로 붙일 수 있는 거리인 now보다 큰 지를 확인한다. 만약 now보다 크다면 테이프를 붙이고(여기서 테이프를 붙인다는 말은 cnt에 1을 더하는 것과 같은 의미) now를 새롭게 업데이트한다. 즉, 테이프를 붙인 지점으로 부터 테이프가 최대 붙는 거리까지를 업데이트한다. 따라서 다음 구멍의 위치가 now보다 작다면 테이프가 커버될 수 있는 위치라는 의미로 테이프를 더 붙여줄 필요없이 넘어가면 된다. 즉 이러한 상황에선 cnt에 1을 더할 필요가 없다.

이렇게 위치를 오름차순으로 확인하면서, 테이프가 커버할 위치를 벗어나는 구멍의 위치에는 테이프를 새롭게 또 붙이고 now를 업데이트하면 된다. 결과적으로 최소 붙여야하는 테이프의 개수가 cnt에 담기게 된다.