---
title: '[Greedy + Priority Queue] 백준 1781번 컵라면 문제'
author: baduk
date: 2024-01-23 10:36:00 +0900
categories: [Study, Data Structre and Algorithm]
tags: [study, python, problem solving, algorithm]
use_math: true
---
## 문제 간단소개
문제를 맞추면 컵라면을 주는데, 데드라인이 있기 때문에, 이 데드라인을 고려하면서 최대로 받을 수 있는 컵라면 개수를 구하는 문제다.

## 문제접근
내가 처음에 생각한 방식은 컵라면 개수를 기준으로 오름차순으로 정렬하여, 컵라면 개수가 많은 문제부터 처리하도록 하고, 데드라인이 널널한 문제라면 큐에 넣어놨다가, 큐에 있는 문제중 데드라인이 다되어가는 문제는 꺼내서 sum_(컵라면 총합을 저장하는 변수)에 더해서 업데이트 하는 방식을 생각했다.

일단 이러한 아이디어를 코드로 구현하는데 복잡하고 어려웠다. 결국 코드는 완성하지 못했었다. 그러다가 이 문제의 솔루션을 봤는데, 솔루션의 아이디어는 먼저 데드라인이 낮은순으로 정렬을 하고 우선순위 큐에다가 저장하다가 데드라인이 우선순위 큐의 사이즈보다 크면 pop해서 컵라면 개수가 가장 적은 것을 버리도록 구성하였다.

솔루션 보기전까지 큐를 사용해야 할 것 같다는 생각까지는 했는데, 먼저 정렬을 어떻게 진행하고, 어떤식으로 푸쉬 및 팝을 할지에 대해서 감을 못잡았었다.

## 문제풀이 아이디어
데드라인이 아무래도 낮은 것(급한것)부터 처리해야하므로 오름차순으로 정렬하여 데드라인이 낮은 것을 먼저 큐에 넣는데, 큐에 들어간 개수가 새로들어온 문제의 데드라인보다 크다면, 큐에 들어간 문제를 다 풀 수 없게 된다. 따라서 데드라인 상관없이 컵라면 개수가 제일 적은 것을 빼주어 큐에있는 문제의 개수와 현재 막 새로 들어온 데드라인의 크기를 같게 만든다. 이런식으로 컵라면을 가장 적게 주는 문제를 제외시켜 큐에 있는 나머지 모든 문제들을 풀 수 있게 될 것이다.

어쨌든 각각의 모든 문제들이 데드라인은 정해져있으므로 모든 문제를 다 해결할 수는 없고, 컵라면 개수가 가장 적은 문제를 우선적으로 버려야할 것인데, 이러한 아이디어를 우선순위 큐를 사용하여 구성할 수 있다는게 신기했다.

## 제출코드
```python
import heapq
import sys
input = sys.stdin.readline
n = int(input())
problem_list = []
problem_list = list(tuple(map(int,input().split())) for _ in range(n))
problem_list.sort()
q = []
for problem in problem_list:
    p_dl = problem[0]
    p_cup = problem[1]
    heapq.heappush(q,p_cup)
    if len(q)>p_dl:
        heapq.heappop(q)
print(sum(q))
```
## 후기
우선순위 큐를 이용한 그리디 문제에 익숙하지 않으면 이러한 아이디어를 떠올리는 것은 매우 어려울 수 있지만, 그 아이디어에 따라 코드를 구현하는것은 쉬운 문제였다.
