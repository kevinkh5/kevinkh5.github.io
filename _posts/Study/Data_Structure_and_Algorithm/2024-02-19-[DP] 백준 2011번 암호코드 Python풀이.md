---
title: '[DP] 백준 2011번 암호코드 Python풀이'
author: baduk
date: 2024-02-19 18:19:00 +0900
categories: [Study, Data Structre and Algorithm]
tags: [study, python, problem solving, algorithm]
use_math: true
---
출처:
<https://www.acmicpc.net/problem/2011>

## 문제 간단소개
A=1, B=2, C=3, ... , Z=26 이라고 할때 , BEAN을 암호화하면 25114라는 글자가 나온다. 하지만 25114는 BEAN이라는 글자말고도 여러 알파벳으로 해석될 수 있다. 이때 암호인 수의 나열이 주어졌을 때 해석될 수 있는 암호의 가짓수 구하라.

## 문제 접근
이 문제는 정답률 20퍼센트로 정답률이 꽤 낮은 문제다. 푸는데 상당한 시간이 걸렸다… 오늘 하루종일 이 문제만 계속 붙잡고 있었던 것 같다.

이 문제는 규칙성을 발견하고 점화식을 세우면서 해결하는 동적계획법 문제다. 그래도 규칙성은 직접 수를 넣어보고 구해보면서 금방 알 수 있다. 하지만 이 문제는 규칙성 발견 뿐만 아니라 조건에 맞지 않는 케이스에 대해서도 꼼꼼하게 고려해야 하는 문제다.

예를들어 10, 20은 알파벳 변환이 가능하지만, 30,40은 알파벳 변환이 불가하다. 또한 05, 07과 같이 앞에 0을 붙인 수도 변환이 불가하다. 그리고 그냥 0도 알파벳 변환이 불가하다. 이러한 케이스들을 다 생각하고 고려해야한다는 점이 이 문제가 간단한듯 하면서도 다소 까다로운 이유다.

## 문제 풀이 - 규칙성 발견
규칙성 발견을 위해, 아래에서 숫자를 붙여가면서 예시를 들어보겠다.

예를들어 ’2 5’라는 암호를 해석했을 때 몇가지가 해석될 수 있는 지를 보자.

```
1.[2, 5]
2.[25]
```
이렇게 두가지가 나올 수 있다.

그렇다면 '2 5'라는 수에 1을 더해서 '2 5 1'이라는 암호를 해석했을 때는 몇가지가 나올까?

```
1.[2, 5, 1]
2.[25, 1]
3.[2, 51] (X)
```
이런식으로 나올 수 있는데, 3번의 경우 51은 26을 넘어간 수다. 51로 변환할 수 있는 알파벳은 없으므로 3번은 케이스에서 제외시켜야 한다. 따라서 2 5 1’이라는 암호의 해석은 두 가지(1번케이스,2번케이스)다.

만약 ‘2 5’라는 수가 아닌 ‘2 2’라는 수에 1을 더하여 ‘2 2 1’이라는 암호를 해석했다면 몇가지가 나올까?

```
1.[2, 2, 1]
2.[22, 1]
3.[2, 21]
```

위와 같이 3가지 경우가 나왔을 것이다.

위 3가지를 보면 1번과 2번은 ‘ 2 2’라는 암호의 해석 수이고, 3번은 ‘2’라는 암호의 해석 수라는 것을 알 수 있다.

즉, 

```
‘2 2 1’의 암호의 해석 수 = ‘2 2’의 암호 해석 수 + ‘2’의 암호 해석 수
```

좀 더 일반화해서 표현해 보자면,

```
arr[0:n]의 해석 수 = arr[0:n-1]의 해석수 + arr[0:n-2]의 해석 수
```

라고 할 수 있다.

하지만 다시 돌아가서 ’2 5 1’이라는 암호를 해석 할 때는

```
’2 5 1’의 암호 해석수 = ‘2 5’의 암호 해석수 + ‘2’의 암호 해석수
```

위 식은 성립되지 않는다. 그 이유는 ‘2’의 암호 해석수를 구할 때 2 뒤에는 51을 붙여줘야 한다는 조건이 필요한데, 51로 변환할 수 있는 알파벳이 존재 하지 않기 때문이다.

즉, 

```
’2 5 1’의 암호 해석수 = ‘2 5’의 암호 해석수
```

일반화해서 표현하자면

```
arr[0:n]의 해석 수 = arr[0:n-1]의 해석수
```

위 식이 성립한다.

## 문제 풀이 - 핵심 아이디어

따라서 우리는 숫자를 가져오면서 알파벳 변환이 가능한 수 인지에 대한 체크를 염두에 두어야 한다.

예를들어 A B C D E 라는 암호가 나열되어 있다고 하자.(여기서 A B C D E는 암호화 하기 이전에 알파벳이 아니라 숫자를 변수처럼 표현한 것이다.) F라는 수를 새로 붙여서 A B C D E F라는 암호의 해석 개수를 구하고자 한다면 F가 먼저 0인지 아닌지를 확인해야 한다.

### 1.F가 0이 아닌 경우
만약 F가 0이 아니라면 F는 1,2,3,4,5,6,7,8,9중 한 수이다.

즉, F라는 수는 알파벳으로 부터 변환될 수 있는 수라고 볼 수 있고, A B C D E와 따로 떼어서 사용할 수 있는 수 라고 이해할 수 있다.

즉, F가 0보다 크다면, ‘A B C D E F’라는 암호의 해석 개수는 ‘A B C D E’라는 암호의 해석 개수를 기본적으로 포함하고 있다고 할 수 있다.

따라서 일단 dp테이블에 arr[0:n-1]의 해석 수를 저장해둔다.

그 다음 F의 앞에 있는 E를 봐야한다.  만약에 E*10+F가 10이상 26이하라면 ‘E F’라는 암호는 ‘A B C D’와 따로 떼어서 사용할 수 있다. 즉, ‘A B C D’라는 암호의 해석 수를 포함할 수 있다. 

따라서 이 경우에는 앞서 dp 테이블에 저장해둔 arr[0:n-1]의 해석 수에다가 arr[0:n-2]의 해석수를 더해서 업데이트한다.

즉, 아래식 처럼 될 것이다.
```
arr[0:n]의 해석 수 = arr[0:n-1]의 해석수 + arr[0:n-2]의 해석 수
```

하지만 E*10+F가 10보다 작다면, EF는 00,01,02,03,04,05,06,07,08,09이라는 소리고, 이러한 케이스일 경우
‘E F’라는 암호는 ‘A B C D’와 따로 떼어서 사용할 수 없다. 즉, arr[0:n-2]의 해석 수는 포함시킬 수 없고,
아래의 식으로 dp테이블에 업데이트 될 것이다.

```
arr[0:n]의 해석 수 = arr[0:n-1]의 해석수
```

10보다 작은 경우 뿐만아니라, 27이상이 되는 수에 대해서도 마찬가지로 ‘E F’라는 암호는 ‘A B C D’와 따로 떼어서 사용할 수 없으므로 위 식이 동일하게 작용된다.


### 2.F가 0인 경우
이제 F가 0인 경우를 생각해보자.

F가 0인 경우 ‘A B C D E’라는 수와 따로 떼어서 사용할 수 없다. 따라서 arr[0:n-1]의 해석에 대해서 고려할 수 없으므로
arr[0:n-1]의 해석 수를 더하지 않는다.

하지만 F가 0이더라도 E*10+F가 10이상 26이하의 수라면 ‘A B C D’라는 수와 떼어서 사용할 수 있다. 따라서 E*10+F가 10이상 26이하의 수를 만족하면 dp 테이블에 arr[0:n-2]의 해석수를 더해준다. 아래식과 같이 dp 테이블에 업데이트 될 것이다.

```
arr[0:n]의 해석 수 = arr[0:n-2]의 해석수
```

만약 F가 0이면서 E*10+F가 10이상 26이하의 수를 만족하지 않다면, 이 때는 어떠한 방법으로든 암호를 해석할 수 없다. 그 이유는 EF를 따로 떼어서 사용할 수도 없고, F를 따로 떼어서 사용할 수도 없기 때문이다. 이런경우에는 무조건 0을 출력한다.

## 제출코드
```python
import sys
input = sys.stdin.readline

arr = list(map(int,input().rstrip()))
if arr[0] == 0:
    print(0)
    sys.exit(0)
dp = [0] * (len(arr)+1)
dp[0] = 1
dp[1] = 1

for i in range(1, len(arr)):
    if arr[i] == 0 and arr[i-1] == 0:
        print(0)
        sys.exit(0)
    if arr[i] != 0:
        dp[i+1] = dp[i]
    if 10 <= 10*arr[i-1] + arr[i] <= 26:
        dp[i+1] += dp[i-1]
print(dp[-1]%1000000)
```

## 배운 점
이 문제를 풀면서 느낀 점이 있다. 명확하게 문제를 이해하고 솔루션 로직을 명확히 잡고 있다면, 코드를 좀 더 가독성 높여 간결하게 작성할 수 있다. 하지만 문제 분석을 제대로 하지 못하고, 코드를 복잡하게 작성하면 어디서 틀렸는지 찾는것이 쉽지 않다. DP문제에서 규칙성을 발견했다면, 여러가지 케이스에 대한 고려도 잘 이루어졌는지 꼼꼼히 분석하는 습관을 들여야 겠다.