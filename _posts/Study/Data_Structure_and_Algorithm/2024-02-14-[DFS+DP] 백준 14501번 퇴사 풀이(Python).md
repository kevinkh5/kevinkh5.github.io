---
title: '[DFS+DP] 백준 14501번 퇴사 풀이(Python)'
author: baduk
date: 2024-02-14 16:09:00 +0900
categories: [Study, Data Structre and Algorithm]
tags: [study, python, problem solving, algorithm]
use_math: true
---
출처:
<https://www.acmicpc.net/problem/14501>

## 문제소개
상담원의 시간과 상담금액이 주어진다. 특정 상담시간 만큼 상담하면 해당 상담에 대한 상단금액을 벌 수 있지만, 다른 상담을 못할 수도 있다. 여러 상담중 적절히 골라 상담했을 때, 최대 벌 수 있는 상담금액 구하기.

## 문제접근
일단 문제이해는 크게 어렵지 않았다.
다만 이해를 바탕으로 로직을 어떻게 구성해야할지 떠올리는것이 쉽지 않았다. 이 문제는 실버 문제이지만 개인적으로 많이 어려웠다. 문제풀이는 결국 떠올리지 못하고 솔루션을 참고했다.

이 문제는 크게 두가지 방식으로 풀 수 있다. 하나는 DFS방식, 다른하나는 DP방식이다. 문제 제한사항을 보면 N이 최대 15밖에 안되므로 브루트포스 방식으로 다 찾아내서 최대값 구하는 것도 해볼만 할 것이다. N이 15면 상담을 하냐 안하냐 2가지 경우가 15번 있는것으로 시간복잡도는 최대 2의 15제곱이 될텐데, 2의 15제곱은 3만정도 밖에 안되므로 브루트포스방식을 써도 문제가 되지 않을 것이다.

## DFS풀이
먼저 DFS방식으로 모든 경우를 찾아서 해결해보자. 솔루션에서 얻은 가장 큰 힌트는 상담을 하냐 안하냐를 그림으로 표현하여 탐색한다는 아이디어를 사용해야 한다는 것이다.

아래그림과 같이 0번 인덱스 부터 시작하여, 0번에 해당하는 상담시간이 3이고, 만약 상담을 한다면 0+3번 인덱스로 이동하여 0번 인덱스에 대한 상담금액을 더한다. 그리고 0+3번 인덱스에 대한 상담시간이 만약 1이고, 만약 해당 인덱스에 대한 상담을 한다면 0+3+1번 인덱스로 이동하여 상담금액을 또 더한다.

<img src='https://lh3.googleusercontent.com/pw/ABLVV84q_We-23-iuIjtehmX0x2YsA7U7HAGkCTYsa2PkUCG-QfCMK87d2wxmZG-d69sG1DOCcLXVUgliwY5f9P3rzZb102ipW307avC7g0PNVy9hI4UeobqB1mgg-AJ18A8NtFkDfPxX8AUpe4h7nAtafok=w611-h644-s-no-gm?authuser=0' alt=exam width=500>

이러한 과정을 반복하다가 더 이상 상담을 못하게 되면 상담금액을 누적해서 합해온것을 최대값을 넣을 변수에 새로 업데이트한다. 이러한 과정을 DFS방식으로 모두 탐색해서 최종적인 최대값을 구하여 출력하면 된다.

코드 구현시 주의해야할 점은 다음 인덱스로 넘어 갈 때, 리스트의 사이즈 이상이 되지 않도록 인덱스 에러에 주의해야 한다. 다음 인덱스로 넘길때 리스트 크기와 같은 수와 큰 수를 모두 넘길 수는 있지만, 리스트의 크기와 같거나 큰 수가 넘어가면 리스트 접근 하기 이전에 리턴처리하는 것을 잊지 말아야 한다.

풀이는 복잡하지 않지만 코드 구현과정에서 인덱스에러가 때문에 다소 까다로웠다.

## DFS방식 제출코드
```python
import sys
input = sys.stdin.readline

n = int(input())
arr = [tuple(map(int,input().split())) for i in range(n)]
global max_money
max_money = 0
def dfs(start,money,n):
    global max_money
    if start >= n:
        max_money = max(max_money,money)
        return
    if start + arr[start][0] <= n:
        dfs(start + arr[start][0],money + arr[start][1],n)
    dfs(start+1,money,n)

dfs(0,0,n)
print(max_money)
```

## DP방식 풀이
DP방식 풀이는 뒤에서 거꾸로 오면서 최대값을 업데이트 해오면 된다. 맨 끝 인덱스부터, 해당 인덱스에 대한 상담을 하냐 안하냐 두 가지 경우의 수를 구해서 두가지 경우 중 큰 값을 DP테이블에 업데이트 하면 된다. 먼저 상담을 할 경우에 대해서 생각할 때는 상담이 가능한지 부터 확인해야 한다. 만약 상담시간이 리스트 크기 초과하여 넘어가면 애초에 상담을 못하기 때문에 상담을 안한 것에 대한 값을 DP테이블에 업데이트 해야 한다.

만약 상담이 가능하다면 반복문에서 현재 i가 가리키고 있는 상담에 대한 시간과 i를 합한 값을 구한다. 그리고 그 구한 값을 Key로하여 DP테이블로 찾아가서 해당 위치에 대한 DP테이블의 값과 반복문에서 i가 가리키고 있는 상담금액을 더해서 dp테이블에 업데이트 하면된다. 그 이유는 일단 상담이 가능하다는 것은 해당 상담을 진행하여 상담금액을 벌 수 있으므로 그 값을 포함해야하기 때문이고, 또한 이 값에다가 뒤에서 벌어들일 수 있는 최대 금액을 더하면 최대값을 구할 수 있기 때문이다.(이 아이디어를 떠올릴 수 있어야 하는 것이 DP풀이의 핵심일 것이다)

만약 상담이 불가능하다면 i+1을 key로하여 DP테이블에서 값을 그냥 가져오면 될 것이다. 그 이유는 상담이 불가능하다는 것은 현재 가리키고 있는 상담금액에 대한 값은 필요가 없으며 따라서 이전까지 구해온 값을 그대로 가져오면 되기 때문이다.


## DP방식 제출코드
```python
import sys
input = sys.stdin.readline

n = int(input())
t_list = [0]*n
p_list = [0]*n

for i in range(n):
    t,p = map(int,input().split())
    t_list[i] = t
    p_list[i] = p

dp = [0]*(n+1)
for i in range(n-1,-1,-1):
    if t_list[i] + i <= n:
        yes = dp[t_list[i] + i] + p_list[i]
        dp[i] = max(yes,dp[i+1])
    else:
        dp[i] = dp[i+1]
print(dp[0])
```

## 후기
문제가 질적으로도 상당히 좋다는 느낌이 들었다. 이 문제가 여러가지 접근을 가지고 풀 수 있는 문제이기 때문에 그런것 같다.(DFS(브루트포스),메모이제이션을 활용한 DP풀이) 결과적으로 제출한 코드는 간결하지만 구현이 쉽지는 않았다. 분명 문제에서 주어진 테스트케이스는 모두 통과했는데, 다른 케이스에서 통과하지못해서 인덱스 에러에 대한 디버깅하느라 상당히 애먹었다. 구현이 다소 어려운 문제의 코드를 작성할 때는 최대한 간결하고 깔끔하게 해야 테스트 통과확률을 높일 수 있는 것 같다. 그리고 간결한 코드 작성을 위해 결국 손코딩으로 먼저 풀면서 백퍼센트 이해를 해야할 것 같다. 코드작성부터 들어가는 순간 더 헷갈리고 힘들어질 수 있는 것 같다.


