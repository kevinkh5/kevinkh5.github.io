---
title: '[Segment-Tree] 값이 바뀔 수 있는 수열의 구간 합을 세그먼트트리로 효율적으로 구해보자 with 백준 2042 구간 합 구하기'
author: baduk
date: 2024-03-10 20:05:00 +0900
categories: [Study, Data Structre and Algorithm]
tags: [study, python, problem solving, algorithm]
use_math: true
---

## 세그먼트트리(Segment Tree)
세그먼트 트리는 인덱스트리의 한 종류로서 구간 합을 구할 때 사용한다. 사실 간단한 합 배열만으로도 구간합을 구할 수 있지만, 데이터를 업데이트하면서 구간합을 구해야 하는 상황에서는 합 배열로 구하는 알고리즘은 성능이 나쁘다. 그래서 이때는 세그먼트 트리 자료구조를 사용해야 한다.

## 세그먼트트리 구현

### 1.트리의 크기 구하기

먼저 세그먼트트리를 1차원 배열로 초기화해야하기 때문에 트리 크기를 미리 알아야 한다. 이때 트리 크기를 구할 때, 트리에서 Leaf노드가 될 수열의 데이터 개수를 가지고 판단해야 한다. 먼저 이진트리의 노드 개수와 높이의 관계를 나타내면 아래와 같다.

$ 노드의 개수_N = 2^{(h+1)} - 1 $

그렇다면 Leaf노드의 개수는 어떻게 구할 수 있을까?

Leaf노드의 개수를 구하는 것도 간단하다. 높이가 h인 leaf 노드의 개수를 구하려면 `(높이 h에서의 노드 개수)-(높이 h-1에서의 노드 개수)`를 구하면 된다. 따라서 아래와 같다.


$ Leaf_N = (2^{(h+1)}-1) - (2^h-1) $

따라서 정리하면 

$ Leaf_N = 2^h $

이렇게 Leaf노드와 높이 h와의 관계를 표현할 수 있다. 그런데 예를들어 Leaf 노드의 개수가 7이라고 하면, 트리의 높이를 어떻게 구성해야할까?

만약 데이터 개수가 7개여서 Leaf노드의 개수가 최소 7인 트리가 필요한 상황이다. 그런데 이 상황에서 트리의 높이를 2라고하면, 높이 2인 트리에서의 Leaf노드의 개수가 4개로, 즉 4개의 Leaf노드 공간밖에 없어서 데이터를 채우기에 공간이 부족해진다. 따라서 $7 <= 2^h$ 을 만족하는 최소 높이 h를 구해야 하고, 이때 h = 3이 된다. 이를 일반화하자면 우리가 구하고자 하는 트리의 높이는 결국 $Leaf_N <= 2^h$ 을 만족하는 최소의 h가 된다.

위 예시에서 Leaf 노드의 개수가 7이어서, 높이 h = 3이 나왔고, 이를 노드의 개수를 구하는 식에서의 h에 3을 대입하면, 아래와 같다.

$ 노드의 개수_N = 2^{(3+1)} - 1 = 15 $

노드의 개수는 15가 된다. 즉, 8개의 Leaf노드를 가진 트리를 구성하려면 최소 15개의 노드 공간이 필요하다. 하지만 우리가 리스트 초기화를 할 때 인덱스 0을 비워두고 1부터 시작을 할 것이기 때문에, 리스트 크기는 15가 아니라 +1 한 값으로 16으로 초기화한다.

정리하자면, 먼저 Leaf노드의 개수에 맞게 트리의 높이를 얼마나 맞춰야 하는지를 계산한 후, 그 높이를 가지고 트리의 공간의 크기를 결정하고, 트리를 초기화 해주면 된다.


### 2.트리의 인덱스 업데이트
Leaf노드의 개수가 8개라면 Leaf노드 중 첫번째 노드의 인덱스는 몇이 되어야 할까?

Leaf노드가 8개라면,  $2^h >= 8$ 을 만족하는 최소 정수 h는 3으로 높이가 3인 트리로 초기화 될 것이다. 그럼 높이가 h-1인 즉, 높이가 2인 노드의 총 개수 만큼 더하면 그것이 첫번째 Leaf노드의 인덱스가 될 것이다.

예를들어 높이가 2인 노드의 총 개수는 7개니까, 높이가 3일 때 첫번째 Leaf노드의 인덱스는 7+1, 즉 8이 될 것이다.

그럼 수열에서 인덱스 1(첫번째)부터 3까지의 구간 합을 구하는 상황에서는 구하고자 하는 인덱스에 7을 더한 값으로 업데이트하여 8부터 10까지의 구간합을 구하면 된다.

이와 같이 트리의 인덱스를 업데이트 해줄 때 더해줄 값 즉, 높이 h-1에서의 노드의 총 개수, $2^h-1$ 을 left_node_start_index 변수에 담아서, 노드가 가지고 있는 값을 변경하거나 구간 합을 구할 때 사용되는 인덱스에 left_node_start_index를 더하여 이용한다.

### 3.수열을 트리에 업데이트한다.
이제 위에서 구한 left_node_start_index를 이용하여 초기 트리에 우리가 담을 수열을 채워주어야 한다. 따라서 left_node_start_index+1 부터 left_node_start_index+n(데이터 개수)까지 인덱스에 접근하여 수열의 값을 채워준다. 그리고 나서 우리가 담을 수열을 기반으로 그 위에 부모노드들을 모두 업데이트 시켜준다. 부모노드 업데이트 과정은 맨 끝 인덱스부터 1씩 줄여가면서 순회를 하고, 2를 나눈 몫으로 부모노드에 접근하여 업데이트 해나간다. 만약 구간합을 구하는 세그먼트 트리라면 이 과정에서 각각의 자식노드가 가진 값을 부모노드에 더하면서 업데이트 한다.

### 4.구간 합 구하기
세그먼트트리로 구간 합을 구하는 원리는 다음과 같다. 구간 합을 구하기 위한 시작지점 start를 놓고, 끝지점을 end로 놓는다. 그리고 start가 end보다 커지는 지점이 나타나기 전까지 반복을 진행할 것이다.

이 과정에서 만약 start%2가 1이라면 start가 가리키는 노드가 우측 자식노드이기 때문에, 해당노드의 부모노드를 다음 루프에서 선택하면 안된다. 왜냐하면 해당노드의 부모노드를 선택할 경우, 구간에 포함되지 않는 좌측노드까지 같이 포함이 되기 때문이다. 따라서 start%2가 1이라면 현재 start가 가리키는 노드의 값을 따로 합해서 저장해놓고 다음 위치를 start+1//2로 옮긴다. 여기서 start에 +1을 한 이유는 해당노드의 부모가 아닌 그 오른쪽에 있는 부모노드를 가리키도록 하기 위함이다. 만약 start%2가 0이면 현재 start가 가리키는 노드는 왼쪽 자식 노드니까 따로 합해놓는 과정없이 다음노드를 부모노드로 가리키도록 하면 된다.

end는 이와 반대다. 반복하는 과정에서 end%2가 0이라면 end가 가리키는 노드는 좌측 자식노드로 해당 노드의 부모노드를 다음 루프의 포인터로서 선택하면 안된다. 왜냐하면 해당노드의 부모노드를 선택할 경우, 구간에 포함되지 않는 우측노드까지 같이 포함이 되기 때문이다. 따라서 end%2가 0이라면 현재 end가 가리키는 노드의 값을 따로 합해놓고, 다음 위치를 end-1//2로 옮긴다. end-1을 한 이유는 현재 부모노드가 아닌 그 왼쪽 부모노드를 가리키기 위함이다. 만약 end%2가 1이면 현재 end가 가리키는 노드는 오른쪽 자식 노드로 따로 합해놓는 과정없이 다음노드를 부모노드를 가리키도록 하면 된다.

위와 같은 과정을 거치다가 결국 start가 end보다 커지는 지점이 나타나고 반복은 종료된다. (start는 2로 나눈 몫을 구하는 과정에서 언젠가는 1 또는 3처럼 홀수 값이 나올 수 있다. 즉, start의 값이 홀수가 되어 start%2 = 1이 되고, 해당 조건에 의해 start값이 커져서 end보다 커지는 지점이 반드시 나타난다. 따라서 무한루프는 발생하지 않는다.)

### 5.데이터 값 변경하기
데이터 값 변경 과정도 크게 어렵지 않다. 바꾸고자 하는 노드의 인덱스를 찾아서 `(새로 바꾸고자 하는 값) -  (현재 가지고 있는 값)` 즉, 현재값과 새로운값의 차이를 구해서 그 차이만큼을 Leaf노드부터 부모노드로 더해주며 전파시켜나가면 된다.

트리 값 변경은 자식노드에서 부모노드로 이동하는 과정에서 일어난다. 업데이트 최대 양은 최대 트리의 높이(or깊이)이기 때문에, 데이터가 많더라도 트리의 높이 만큼만 업데이트 해주면 돼서 시간복잡도가 상당히 효율적이라는 것을 알 수 있다.


## 세그먼트트리 파이썬 코드 구현(백준 2042번)
```python
import sys
import math
input = sys.stdin.readline

n, m, k = map(int, input().split())
height = math.ceil(math.log2(n))
tree_size = pow(2, height + 1)
tree = [0]*(tree_size)
left_node_start_index = pow(2,height) - 1

# 트리에 데이터값 채우기
for i in range(left_node_start_index + 1, left_node_start_index+n+1):
    tree[i] = int(input())

def create_tree(i):
    while i != 1:
        tree[i // 2] += tree[i]
        i -= 1

create_tree(tree_size - 1)

# 구간 합 구하기
def interval_sum(start, end):
    part_sum = 0
    while start <= end:
        if start % 2 == 1:
            part_sum += tree[start]
            start += 1
        if end % 2 == 0:
            part_sum += tree[end]
            end -= 1
        start = start//2
        end = end//2
    return part_sum

# 값 업데이트
def update_value(index, value):
    diff = value - tree[index]
    while index > 0:
        tree[index] = tree[index] + diff
        index = index // 2

for _ in range(m + k):
    question, s, e = map(int, input().split())
    if question == 1:
        update_value(left_node_start_index + s, e)
    elif question == 2:
        s = s + left_node_start_index
        e = e + left_node_start_index
        print(interval_sum(s, e))
```