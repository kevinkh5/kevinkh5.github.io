---
title: '[Binary Search] 프로그래머스 징검다리 풀어보기(python)'
author: baduk
date: 2024-02-04 12:05:00 +0900
categories: [Study, Data Structre and Algorithm]
tags: [study, python, problem solving, algorithm]
use_math: true
---
출처:<https://school.programmers.co.kr/learn/courses/30/lessons/43236>

## 문제 소개
도착지점, 바위의 위치를 담은 리스트, 제거할 바위의 수 n을 입력으로 받아서, n개의 바위를 제거했을 때 바위사이의 최소거리가 가장 큰 상황에서의 그 최소거리를 리턴해라.

## 문제 접근
이분탐색 유형의 문제는 이분탐색을 구현할 줄 알아야 하는 것은 기본이고, (이분탐색을 모르면 이분탐색 문제를 못푸는것은 당연)
문제를 풀려면 아래 두가지가 가능해야한다.

```
첫번째는 이 문제가 이분탐색문제인지 아닌지를 알아차릴 수 있어야 한다는 것.

두번째는 이분탐색안에서 활용될 함수를 어떻게 만들지 생각해야하는 것.
```

이 문제에서 이분탐색안에서 활용될 함수를 떠올리는 핵심아이디어는 바로 바위제거를 최소화하면서 최소거리를 어떻게 확보할 것인지에 대한 생각이다.

문제에서는 바위 n개를 제거했을때 나오는 최소의 거리중 최대인 것을 구하라고 했다.

예를들어 아래와 같은 상황에서

`0(출발) 2(바위1) 11(바위2) 14(바위3) 17(바위4) 21(바위5) 25(도착)`

최소거리 10을 확보하려할 때, 적어도 지워야하는 바위 개수는 4개다 (바위2 제외하고 전부다 지워야한다)
근데 최소거리 11을 확보하려할 때도, 지원야하는 바위 개수는 4개로 똑같다. 지워야하는 바위의 개수는 4개로 같지만 10,11 최소거리중 최대는 11이니까 답으로 11을 출력해야한다.

따라서 먼저 최소한 이 정도 거리를 확보하려면(입력) 최소 몇개의 바위를 제거 해야하는지를(출력) 구하는 함수를 만들면된다.

그리고 나서 그걸 이분탐색을 이용해서 해결 하면 된다.

## 풀이 과정(핵심)
문제를 푸는 디테일한 과정은 아래와 같다

먼저 제한사항에서는 도착지점까지의 거리 distance가 최소 1이라고 했으므로,
이분탐색의 start는 1이 되고, 문제 예시처럼 distance가 25로 주어지면, end는 25가 된다.

만약 문제 예시처럼 rocks가 [2,14,11,21,17]일 경우, 이를 편의상 정렬해서 보자면 아래와 같다.

0(출발) 2 11 14 17 21 25(도착)

1~25의 중간값은 13으로, 먼저 최소거리 13을 확보하려면 적어도 최소 몇개의 바위를 제거 해야하는지를 함수에 넣어 구한다.

함수 안에서의 과정은 다음과 같다.

```
먼저 0~2사이의 거리가 2로 최소거리 13이 확보가 안된다. 따라서 2지점 바위제거한다.

0~11사이의 거리가 11로 최소거리 13이 확보가 안된다. 따라서 11지점 바위제거한다.

0~14사이의 거리가 14로 최소거리 13이 확보가 된다. 14지점 바위유지하고,이때부터는 14부터 사이거리를 측정한다.

14~17사이의 거리가 3으로 최소거리 13이 확보가 안된다. 17지점 바위 제거한다.

14~21사이의 거리가 7로 최소거리 13이 확보가 안된다. 21지점 바위 제거한다.

14~25사이의 거리가 11로 최소거리 13이 확보가 안된다. 25지점은 바위가 아니라 도착지점으로 14지점 바위를 제거한다.

이렇게 되면 모든 바위 5개가 제거되므로 5가 출력으로 5를 내보낸다.
```

따라서 최소 13의 거리를 확보하려면 바위 5개를 모두 제거해야한다. 따라서 함수는 5를 출력한다. 하지만 문제 예시에서 입력으로 받은 제거한 바위의 개수는 2개이므로 최소거리 13보다는 작은 범위를 탐색하도록 탐색범위를 좁혀야한다. 최소거리를 좁혀야 바위를 덜 제거하는 쪽으로 유도할 수 있기 때문이다.

그럼 1~12를 탐색할 것이고, 중간값인 6의 최소거리를 확보하기위해 제거해야하는 바위의 개수를 함수에 넣어 구하자면, 3개다(2지점, 14지점, 21지점 바위), 하지만 우리가 입력받은 2개보다 여전히 크므로 또 작은 범위로 탐색범위를 좁힌다. 

그럼 1~5를 탐색할 것이고, 중간값인 3의 최소거리를 확보하기위해 제거해야하는 최소 바위의 개수를 함수에 넣어 구하자면, 1개다(2지점 바위), 우리가 입력받은 2개 보다 작다. 따라서 최소거리에 대한 탐색범위가 큰쪽으로 범위를 좁힌다.

그럼 4~5를 탐색할것이고, 중간값인 4의 최소거리를 확보하기위해 제거해야하는 최소 바위의 개수를 함수에 넣어 구하자면, 2개다(2지점 바위,14지점 바위), 우리가 입력받은 2개와 같다. 하지만 탐색하지 않은 5도 만약 함수에 넣었을 때 2가 나오면, 5가 답이 되어야한다. 그 이유는 문제에서 거리의 최소중 최대를 구하라고 했기 때문이다.

즉 upper bound로 답을 출력해야한다. 따라서 출력할때는 답 딱 들어맞게 나왔을 때는 큰범위를 탐색하도록 유도하되(start = mid + 1), 출력은 start -1 로 해주면 답이 될 것이다.

Start =5, end =5가 나와서 중간값인 5를 탐색하고, 함수에 넣어 받은 결과가 3으로 입력받은 값보다 커서 end가 mid-1로 조정되고 start는 그대로 있으니 start - 1로 구하면 답을 구할 수 있다. 만약 5를 함수에 넣어 받은결과가 2로 입력받은 값과 같게되면, start가 mid+1로 조정되었다해도 start -1로 구하면 5가 나와 답은 나온다.  

Upper bound와 lower bound로 이진탐색 헷갈리지 말자.
Upper bound로 출력할 때 기억해야 할 것은, 정답과 똑같이 나왔을 때 오른쪽 탐색범위를 유도해야하고, 결과를 start-1로 출력해야한다는 것이다.
Lower bound는 정답과 똑같이 나왔을 때는 왼쪽범위 탐색을 유도하고, 결과는 start로 출력해야한다.

## 제출코드
```python
def solution(distance, rocks, n):
    def remove_rock(dist):
        point = 0
        remove = 0
        for rock in rocks:
            if rock - point < dist:
                remove += 1
            else:
                point = rock
        if point != 0:
            if distance - point < dist:
                remove += 1
        return remove
        
    rocks.sort()
    start = 1
    end = distance
    while start <= end:
        mid = (start + end)//2
        if remove_rock(mid) > n:
            end = mid - 1
        else:
            start = mid + 1
    return start - 1
```