---
title: '[Greedy] 프로그래머스 조이스틱 문제'
author: baduk
date: 2024-01-24 14:21:00 +0900
categories: [Study, Data Structre and Algorithm]
tags: [study, python, problem solving, algorithm]
use_math: true
---
## 문제 간단소개
조이스틱 커서를 이동해서 원하는 글자를 만들때, 버튼을 누르는 최소횟수를 출력하는 문제

## 문제접근 및 아이디어
일단 알파벳 조작하는 문제인걸 보고 나는 chr, ord써야한다는 생각이 자연스럽게 떠올랐다. 최소횟수 구해야하므로, 나는 알파벳중에서도 중간쯤에 위치한 n,m을 기준잡고, n보다 작을때의 버튼누르는 횟수, m보다 크거나 같을때의 눌러야하는 횟수를 각각 따로 구분하여 계산하도록 코드를 작성하였다.

일단 상하 버튼을 누르는 횟수 구하는것은 위와 같이 사실 간단하다. (물론 헷갈려서 코드 작성 시간이 길어질 수도 있긴하다.) 문제는 좌우로도 움직여야한는데, 무작정 인덱스 0부터 오른쪽으로 쭉 이동하느냐 0부터 뒤로해서 왼쪽으로 쭉 이동하느냐 등 좌우 이동에 대한 여러 경우의 수를 생각해야 한다. (직접 구해보면 알겠지만, 오른쪽으로 쭉이동하나 왼쪽으로 쭉이동하나, 그 횟수는 같기 때문에 하나만 구해도 된다.)

문제는 쭉 이동하는 것 뿐만 아니라 또 다른 경우도 있다. 예를 들어서 알파벳이 "BAAAAAB"로 나오면, 처음에 인덱스 0에서 A를 B로 바꿔주고(+1), 왼쪽 이동 버튼 눌러서(+1), 또 다시 A를 B로 바꿔주면(+1) 세번만 버튼 누르면 끝난다. 즉, 오른쪽 또는 왼쪽으로 쭉 이동해서 글자를 바꾸면 세번이상 버튼을 눌러야 하기 때문에 버튼누르는 최소값을 구할 수가 없다.

따라서 오른쪽 왼쪽을 왔다갔다해서 이동했을 때에 대한 경우도 고려해야 한다. 그리고 여기서 한가지 발견할 수 있는 사실은 A뭉치가 있을때만 왔다갔다 하는 경우가 최소값이 될 가능성이 생긴다. 그렇다고 A뭉치가 있다고해서 왔다갔다 했을 때 최소값이 되는것도 아니다.

만약 A뭉치가 여러개 있다면 가능한 길이가 긴 A뭉치를 왔다갔다 하는 것이 이동버튼을 최소화 할 수 있을 거라는 생각이 들지만, 그걸 구하는 프로그램을 작성한다는것은 상당히 복잡하지 않을까 싶다.

문제를 풀 때, 로직을 떠올리는것은 상당히 중요한 일이지만, 그 로직을 코드에 어떻게 적용시킬 수 있을 지를 늘 염두에 두어야 하므로, 무작정 로직만 생각하면 안될 듯 싶다. 코드로 작성할 수 있게끔, 로직을 떠올려야 한다.

일단 코드에 적용시킬 로직은 다음과 같다. A뭉치가 0부터 시작되느냐는 중요하지 않다. 즉 A가 인덱스 0에 오든 안오든 그것은 좌우 이동과는 상관 없다. 왜냐하면 애초에 시작이 인덱스 0부터 이기 때문이다. 예를들어 'BAABB'와 'AAABB'를 보자. 이 각각의 글자의 인덱스 0은 문자가 서로 다르고, 최종적인 버튼누르는 횟수도 다르다. 하지만 좌우 최소 이동횟수는 각각의 글자 모두 왼쪽으로 두 번 누르는것으로 그 좌우 이동횟수는 똑같다.

따라서 A뭉치 찾는 과정은 인덱스 1부터 탐색해 나가면 된다. 이와 같은 방법으로 A뭉치가 시작되는 인덱스와 끝나는 인덱스를 구하여 왔다갔다 이동하는 경우의 횟수를 구하면 된다.

여기서 왔다갔다 이동하는 것도 두 가지 경우가 있다.

1.첫번째는 처음에 오른쪽으로 이동하다가 찍고 왼쪽으로 쭉 이동하는 경우

2.두번째는 처음에 왼쪽(뒤)으로 이동하다가 찍고 오른쪽으로 쭉 이동하는 경우

글로만 설명을 이해하는 것은 쉽지 않으므로, 아래 그림을 참고해보자.


<img src='https://lh3.googleusercontent.com/pw/ABLVV86T4HQyY8E-wgdnFT7ez4Ojsl5Og2m-i073i5QqqW3fic8uPVxEmpK6Kj58JOB5AA4_8UGAcwQuEk95qi2lU9jMo_K8rx7I4PmkXNeevVrL9hENGe4EilSZRA2nILlYJC9dADgR3z4W4BDGicJ9L6dZ=w1215-h551-s-no-gm?authuser=0' alt='exam' width=500>

위 그림은 BCAABB라는 글자의 A뭉치를 왔다갔다하는 방식으로 탐색한 것이다.

1번은 오른쪽으로 이동하다가 A뭉치 왼쪽부분 전까지 찍고 뒤로돌아가서 A뭉치의 오른쪽을 전을 찍는 방식이다.

2번은 왼쪽으로 이동하다가 A뭉치 왼쪽부분 전까지 찍고 오른쪽으로 되돌아가서 다시 A뭉치의 왼쪽 전을 찍는 방식이다.

위 그림을 보면 알 수 있듯이, 1번 방식으로 탐색하면 이동횟수가 4이고, 2번 방식은 이동횟수가 5번으로 서로 다를 수 있으므로, 이 두 가지 경우를 모두 구해서 최소값을 구해야 한다.

아래에서 이 문제에 핵심인 좌우 이동횟수 계산하는것을 아래에서 설명해보겠다.

## 이 문제에서 가장 헷갈리고 어려웠던 좌우이동 횟수 구하는 방법
A뭉치에 대한 인덱스를 가지고 1번 방식, 2번 방식에 대한 이동 횟수를 어떻게 계산할 수 있을까?

이 계산의 규칙을 구하는것은 수식적으로 접근하는것 보다 그림으로 이해하는 것이 훨씬 직관적이다. 아래 그림을 참고하면 좌우 이동 횟수를 구하는 과정을 이해하는데 도움이 될 수 있다.

<img src='https://lh3.googleusercontent.com/pw/ABLVV85K4E_xfpnO2G4kZ9PNBirAnfIUkRRF_yf0IkyHV0NUz3GjJdMtUwYXEfU6Ok674L6ym7ksGjiDO7bLVOE_aILBmlfEk8dhqlyS0DtEGc84iHMqEk8-TYcffZfvZxuEYmkjOovKHZAvLVh86mOM8gQA=w1215-h1022-s-no-gm?authuser=0' alt='exam' width=1000>

인덱스의 시작인 0인덱스와 마지막 인덱스는 순환적인 느낌으로 연결되어있으니까, 이러한 아이디어를 가지고 인덱스를 둥글게 원으로 그림을 그려서 이해해보았다.

## 제출코드
```python
def solution(name):
    up_down_count = 0
    for i in name:
        if ord(i)  < 78:
            up_down_count += ord(i) - 65
        else:
            up_down_count += 91 - ord(i)
    name_length = len(name)
    # 여기까지는 버튼 상하를 누르는 최소 횟수의 합

    # 이름의 길이가 한개면 좌우를 누를 필요없으므로, 상하 횟수 return하고 종료
    if name_length == 1:
        return up_down_count

    # 여기서 부터는 좌우 이동횟수를 구하는 과정
    min_move = name_length - 1
    # 만약 A뭉치가 없으면 그냥 역방향/정방향 쭉 이동할 때의 횟수를 리턴해야 하니까
    # 역방향/정방향 쭉 이동할 때 횟수를 min_move에 미리저장한다
    
    for i in range(1, name_length): # 인덱스 1부터 A뭉치 찾으러 돌아다니다가
        if name[i] == 'A':# 찾으면, A가 처음 나오는 위치의 인덱스를 저장하고
            next_i = i

            while next_i + 1 < name_length:
                if name[next_i + 1] == 'A':
                    next_i = next_i + 1
                else:
                    break
            # 여기까지 A뭉치에서 A가 마지막으로 나온 위치의 인덱스를 next_i에 저장한다.
            
            # 아래는 이 문제에서 가장 시간을 많이 잡아먹었던 부분이다.
            # 위 계산은 천재가 아닌 이상, 머리로 계산할 수 없으므로,
            # 반드시 종이에 적어서 계산해야 한다. 머리로 할라하면 헷갈림.
            
            # 먼저 앞으로가서 찍고 뒤로 갈때의 최소 휫수(go_back)와
            # 먼저 뒤로가서 찍고 앞으로 갈때의 최소 휫수(back_go)를
            # 각각 구해서 최소 값을 min_move에 업데이트 한다.
            go_back = (i-1)*2 + (name_length - (next_i+1))
            back_go = 2*(name_length-(next_i+1)) + (i-1)
            min_move = min(min_move, go_back, back_go)

    return min_move + up_down_count
```
## 후기
냅다 코드작성으로 들어가면 디버깅이 힘들어질 수 있는 문제다. 문자열 아스키 코드 관련 문제는 머리로하면 실수할 가능성높아서 반드시 종이에 적어가면 해야할 것 같다. 그리고 계산과정을 인덱스로 다루다보니, 인덱스에러를 주의해야 했다.

이 문제는 특히 다양한 케이스를 스스로 만들어서 여러가지 경우에 대한 상황을 생각해야 했다. 여러 상황을 수치적으로만 하면 헷갈리수 있으니 그림을 그려서 헷갈림을 방지하는것이 중요할 것 같다.
