---
title: '[BFS] 백준 1697번 숨바꼭질 BFS로 해결하기'
author: baduk
date: 2024-01-14 16:35:00 +0900
categories: [Study, Data Structre and Algorithm]
tags: [study, python, problem solving, algorithm]
use_math: true
---
출처:<https://www.acmicpc.net/problem/1697>

## 백준 1697번 숨바꼭질
이 문제는 시작점 위치부터 시간(초)에 따라 이동해가는데, 도착지점에 도착하는데까지 걸리는 최소시간을 구하는 문제다.


## 문제접근
1초당 갈 때 도착하는 지점은 3가지 경우가 나온다 시작점-1, 시작점+1, 2*시작점, 이러 한 경우의 수를 쭉 그려나가면 트리가 만들어진다. 따라서 이 트리를 탐색할 알고리즘을 생각해봐야 할 것이다. 위 트리에서 BFS로 탐색하여  찾아 나가면 같은 level(같은 시간(초))을 먼저 탐색할 수 있으므로 BFS를 사용하여 해결하면 될 것이다.

## 풀이과정
초기변수로 array를 두었는데, 그 이유는 두가지가 있다. 첫번째는 이미 방문한 노드에 대해서는 중복해서 탐색하지 않도록 방지하기 위해서다. 그리고 두번째는 탐색하다가 원하는 지점에 도착하면 그 지점에서의 트리의 Level즉, 시간(초)을 뽑아내기 위해서다.

풀이과정은 다음과 같다. 처음 시작 점을 큐에 넣고 큐에서 하나씩 빼면서 그 큐에서 뺀 위치의 -1, +1, *2를 하나씩 큐에 넣는다. 단 큐에 넣을 때는 이미 중복탐색하지 않은 수여야 하며, 0보다 작으면 안되고, 10만 이상(문제조건에 나와있음)이면 안된다. 그리고 큐에서 노드를 하나씩 빼면서 같은 레벨의 노드먼저 탐색하도록(BFS) 진행해 나간다. 

탐색접근을 위해 큐에 노드를 넣을 때, array[next_pos]에 array[now_pos]+1을 해주는데 그 이유는 다음 접근할 노드의 레벨, 즉 여기서는 초(sec)를 저장하기 위해서다.탐색을 하다가 원하는 지점에 도착하면, array에 저장해놓은 초(sec)를 꺼내고 반복을 중단한다. 

## 헤맸던 곳
나는 한 가지 문제 때문에 계속 “틀렸습니다” 판정을 받았었다. 그 원인은 트리를 구성할 때 큐에 수를 인풋하는 순서가 달라져서, 결과 또한 다르게 출력돼서 그런것 같다. 트리를 구성할 때 앞에서 이미 구성할 때 사용된 수는 중복되어 큐에 삽입하지 않도록 코드를 작성했는데, 그 큐에 인풋하는 순서가 달라지면 트리의 깊이가 깊어질 수록 트리가 다르게 구성될 수도 있는 것 같다. 정확한 원인은 파악하지 못했다. 아무튼 트리를 구성하다가 어딘가 삑사리가 나는것 같다.

정확한 원인은 파악을 못했지만 어쨌든 트리에 작은 숫자부터 차례로 구성하도록 해야 섬세한 탐색이 가능해지고, 중복이 되면 pass 시켜서 좀 더 안정적으로 작동하게 되는 것 같다.

## 제출코드
```python
from collections import deque

MAX = 100001
n, k = map(int, input().split())
array = [0] * MAX

q = deque([n])
while q:
    now_pos = q.popleft()
    if now_pos == k:
        print(array[now_pos])
        break
    for next_pos in (now_pos - 1, now_pos + 1, now_pos * 2):
        if 0 <= next_pos < MAX and not array[next_pos]:
            array[next_pos] = array[now_pos] + 1
            q.append(next_pos)
```


