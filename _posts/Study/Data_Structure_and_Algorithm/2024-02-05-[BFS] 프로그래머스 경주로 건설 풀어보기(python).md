---
title: '[BFS] 프로그래머스 경주로 건설 풀어보기(python)'
author: baduk
date: 2024-02-05 17:12:00 +0900
categories: [Study, Data Structre and Algorithm]
tags: [study, python, problem solving, algorithm]
use_math: true
---
출처:<https://school.programmers.co.kr/learn/courses/30/lessons/67259>

## 문제소개
좌표상에 경주로를 (0,0) 부터 (n-1,n-1)까지 만드는 문제다. BFS를 활용하여 탐색하면서 진행해야한다. 단, 조건이 있다. 일직선으로 갈때 비용과 꺾일 때 비용이 다르다. 이점 고려해서 경주로 만드는 최소비용 구하기.

## 문제접근
이 문제는 BFS탐색으로 푸는 문제긴 한데 아이디어를 떠올리지 못하면 해결하기가 굉장히 어려운 문제다. 이 문제는 단순 최단거리를 구하는게 아니라, 최소비용을 구하는 것이다. 이 문제의 포인트는 도로가 일자로 가냐 꺾이냐에 따라 비용이 달라진다는 것이다.

나는 처음에 어쨌든 최소비용을 구하면 되니까, 도로가 가능한 안꺾이도록 탐색을 해서 처리하면 될 것 같다 싶어서 계속 어떻게 하면 가능할지 고민했던것 같다.

하지만 해결하지 못하고 결국 솔루션을 확인했다.

## 문제풀이
보통 그래프 탐색 할 때 행렬을 상하좌우 확인하면서 탐색하는데,

나는 이 걸 코드화 시킬때
```python
dx=[-1,1,0,0]
dy=[0,0,-1,1]
```
이런 식으로 만들어서 for 문으로 0~3돌려서 변화시킨다.

근데 이 문제는 그렇게 하기보다는

```python
dxy=[(1,0),(-1,0),(0,1),(0,-1)]
```
이런식으로 코드를 작성하고 이 요소에 대한 인덱스를 큐에 저장해서 전에 어떠한 방식으로 탐색했는지를 기억시키는 방식으로 가야한다.
그래야지 길을 탐색할때마다(=도로를 만들때마다) 비용계산이 가능해진다. 예를들어 받아온 인덱스와 새롭게 받은 인덱스가 같으면 다음 도로는 일자도로에 대한 비용을 소비할것이고, 아니면 꺾인 도로비용에 대해서 소비할 것이다.

또한 처음 시작할때 아래로 시작할지 오른쪽으로 시작할지에 따라서도 비용이 다르게 책정되므로 두개를 각각 시도해서 최소값을 리턴해야한다.

## 이슈발생
```python
if index == i:
    ncost = cost_map[x][y] + 100
else:
    ncost = cost_map[x][y] + 600
```
처음에 코드 작성할때 위와 같이 ncost를 업데이트 할 때, cost_map리스트로 부터 값을 가져와서 업데이트하는 방식으로 작성해서 제출했는데, 채점 결과 몇몇 테스트에 대해 실패하였다.

정확한 원인은 밝히지 못했는데 대충 추측하자면, 새로운 값을 변수에 업데이트할때, 이전에 기록된 리스트의 값을 가져와서 업데이트하는데,
만약 이전에 기록된 리스트의 값이 추후에 또 업데이트 될 여지가 있고 그럼 뒤에서 꼬일 수도 있어서 오답이 나온것 같다.

내 생각엔 리스트에 있는 값을 가지고 업데이트하는건 후에 예기치 못한 이상한일이 발생할 수도 있어서 조심해야하고, 차라리 리스트가 아닌 단순변수를 가지고 업데이트 하는 것이 안전할듯 싶다.(이 문제에 대해서는)

확실한 건 리스트이용한 업데이트는 누적데이터를 가져오는거고, 단순변수를 가지고 업데이트하는건 직전데이터를 가지고 하는건데, 이 문제는 누적데이터를 가지고 업데이트하기에 적합하지 않아서 인것 같다. 이 문제에서 도로를 만들때 직전상황에 따라 비용을 달리해야하는데, 앞에서 부터 쭉 누적해온 상황에 따라 비용을 달리했다가 꼬여서 오답이 나오는 것 같다.

## 제출코드
```python
from collections import deque
def solution(board):

    def bfs(start_index):
        q = deque([(0,0,start_index,0)])
        dxy = [(1,0),(-1,0),(0,1),(0,-1)]
        size = len(board)
        cost_map = [[float('inf')]*(size) for i in range(size)]
        while q:
            x,y,index,cost = q.popleft()
            for i,d in enumerate(dxy):
                nx = x + d[0]
                ny = y + d[1]
                if 0<=nx<size and 0<=ny<size:
                    if board[nx][ny] == 0:
                        if index == i:
                            ncost = cost + 100
                        else:
                            ncost = cost + 600
                        if cost_map[nx][ny] >= ncost:
                            cost_map[nx][ny] = ncost
                            q.append((nx,ny,i,ncost))
        return cost_map[-1][-1]

    return min(bfs(0),bfs(2)) # 0은 밑으로 먼저 갈 경우, 2는 오른쪽으로 먼저 갈 경우
```
