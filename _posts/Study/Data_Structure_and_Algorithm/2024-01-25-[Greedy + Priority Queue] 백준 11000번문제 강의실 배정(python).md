---
title: '[Greedy + Priority Queue] 백준 11000번문제 강의실 배정(python)'
author: baduk
date: 2024-01-25 17:45:00 +0900
categories: [Study, Data Structre and Algorithm]
tags: [study, python, problem solving, algorithm]
use_math: true
---
## 문제 간단소개
시작시간과 종료시간을 가진 각각의 수업이있다. 이 수업들을 다 진행해야할 때, 필요한 강의실의 최소개수 구해라.

예를들어 두 수업이 있는데, 그 두 수업이 겹쳐지면 한 강의실에서 수업못하므로 두개의 강의실이 필요하다. 수업 두개가 겹쳐지지 않으면 한 강의실에서 두 수업을 진행할 수 있으므로 강의실 한개만 있으면 된다.

## 문제 오해했던 부분
나는 처음에 선생님 한명이 수업을 진행하는 거라고 잘못 생각해서, 문제 이해하는데 시간이 좀 걸렸다. 선생님이 한명인데 어떻게 시간이 겹쳐질 수 있지라고 한참 고민했다...

## 문제풀이
1.시작시간을 기준으로 오름차순으로 정렬한다. 만약 정렬한 후 시작시간이 같은 경우 종료시간이 더 작은 수가 앞으로오게 정렬한다.

2.최소힙에 첫번째 수업의 종료시간을 넣는다. 두번째 수업의 시작시간은 첫번째수업(현재 최소힙의 Top)의 종료시간과 비교한다. 조건(두번째 수업의 시작시간 >= 첫번째 수업의 종료시간)을 만족하면 최소힙에서 첫번째 수업을 pop하고, 두번째 수업의 종료시간을 push한다. 이 조건을 만족하지 못하면 최소힙에 두번째 수업의 종료시간만 push한다.

3.2번의 과정을 모든 수업에 대해서 적용해서 처리하고, 최종적으로 남은 최소힙의 개수를 출력한다.(최소힙의 최종 개수가 사용해야 할 최소한의 강의실의 개수)

위 풀이가 왜 그러한지에 대한 의문과 디테일한 설명은 아래에 작성해보겠다.

## 시작시간을 기준으로 오름차순 정렬하는 이유는 뭘까?
만약 시작시간이 큰 것이 앞으로 오도록  내림차순으로 정렬하면 뒤에 시작시간이 작은 회의는 앞에 있는 회의의 종료시간보다 빠르게 되고 뒤에 있는 회의의 종료시간이 앞에 있는 회의시간의 시작시간과 또 비교를 해줘야 한다. 일단 이렇게 정렬하면 복잡해진다.

하지만 시작시간을 기준으로 오름차순으로 정렬을 하게되면 앞에 있는 회의시간의 시작시간보다 뒤에 있는 회의의 시작시간이 더늦게되면서, 앞에 있는 회의의 종료시간과 뒤에 있는 회의시작시간을 비교해볼만 해진다.

만약 비교했을때, 뒤에 있는 회의의 시작시간이 앞에 있는 회의의 종료시간보다 빠르면 시간이 겹쳐지므로 강의실이 추가적으로 필요할 것이다. 겹치지 않으면 이어서 한 강의실에서 수업할 수 있으므로, 강의실이 추가적으로 더 필요하지 않다.

그럼 시작시간을 이처럼 오름차순으로 정렬하는것은 알겠는데, 오름차순 정렬에다가 뒤에 종료시간을 오름차순으로 또 정렬해야 하는 이유는 뭘까?

뒤에 종료시간을 오름차순으로 정렬한다는 것은 가능하면 종료시간이 작은(즉,빠른) 것을 앞에 두겠다는 것인데, 가능하면 종료시간이 빠른것을 앞에 두어야, 뒤에 수업을 앞에 수업에 이어붙일 수 있는 공간이 넓어진다. 즉 뒤 시간확보로 뒤에 있는 수업들을 이어붙이기 유리해진다. 따라서 기본적으로는 시작시간을 오름차순으로 정렬하되, 만약 시작시간이 같다면 종료시간이 앞으로 오도록 정렬해야 한다.

## 문제풀이에서 2번과 같은 과정과 같이 조건을 만족할때 pop & push하는 이유는?
(두번째 수업의 시작시간 >= 첫번째 수업의 종료시간) 이 조건을 맞췄다는 것은 첫번째 수업과 두번째 수업을 한 강의실에서 할 수 있다는 뜻으로, 즉 두 수업을 이어붙일 수 있다. 따라서 첫번째 수업의 종료시간은 뒤에 수업의 시작시간과 비교할 용도로는 더 이상 필요 없으니 pop하고 대신 두번째 수업의 종료시간을 push해준것이다. 앞으로는 이 두번째 수업의 종료시간을 뒤에 나올 수업의 시작시간과 비교하게 될 것이다.

## 왜 최소힙을 쓸까?
기본적으로 최소힙을 사용하면 최소힙안에있는 수업 종료시간의 최소값을 알 수 있다. 따라서 종료시간이 최소로 나오는 수와 뒤에 수업을 비교하므로, 가능한 뒤 수업을 앞 수업과 이어붙일 가능성을 높일 수 있다. 앞 수업의 종료시간을 최소화할 수록 뒤에 시간범위가 좀 더 넓어지기 때문이다.

## 왜 이 최소힙의 길이가 사용해야하는 최소강의실의 개수일까?
위 과정에서 이어붙일 수 있는 수업을 만났을때는 pop하고 push를 했다. 즉, pop과 push과정을 통해 최소힙안에서의 개수는 변함을 없게 했다. 하지만 이어붙일 수 없는 수업을 만났을 때는 push만 했다 즉, 개수가 최소힙안에서 1개가 늘어난 셈이 되었다.

다시말하자면 최소힙안에 있는 수업의 개수는 이어붙일 수 있는 강의실을 체크할땐 그 개수가 그대로 이고, 이어붙일 수 없는 강의실을 체크할땐 그 개수가 1개 증가가 된다. 이와 같은 현상을 봤을 때, 최소힙 안에 있는 수업의 개수가 사용해야할 강의실의 개수가 된다고 짐작할 수 있다.

## 제출코드
```python
import sys
input = sys.stdin.readline
import heapq
n = int(input())
arr = [tuple(map(int,input().split())) for i in range(n)]
sorted_arr = sorted(arr, key=lambda x:(x[0],x[1]))
pq = []
heapq.heappush(pq,sorted_arr[0][1])
for i in sorted_arr[1:]:
    if pq[0] <= i[0]:
        heapq.heappop(pq)
        heapq.heappush(pq,i[1])
    else:
        heapq.heappush(pq,i[1])
print(len(pq))
```