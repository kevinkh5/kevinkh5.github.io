---
title: '[Greedy] 백준 19598번 최소 회의실 개수 Python풀이'
author: baduk
date: 2024-03-01 16:09:00 +0900
categories: [Study, Data Structre and Algorithm]
tags: [study, python, problem solving, algorithm]
use_math: true
---
출처:
<https://www.acmicpc.net/problem/19598>

## 문제 간단소개
강의의 개수와 강의의 시간대가 주어진다. 최대한 겹치지 않게 해서 필요한 최소한의 강의실을 구하라.

## 문제접근 및 풀이
이 문제는 백준 11000번 강의실 배정(<https://www.acmicpc.net/problem/11000>) 문제와 거의 똑같다.

<https://kevinkh5.github.io/posts/Greedy-+-Priority-Queue-%EB%B0%B1%EC%A4%80-11000%EB%B2%88%EB%AC%B8%EC%A0%9C-%EA%B0%95%EC%9D%98%EC%8B%A4-%EB%B0%B0%EC%A0%95(python)/>

로직은 간단하다. 시작시간을 기준으로 강의를 정렬한 후, 이전 강의의 종료시간과 새로 가져온 강의의 시작시간을 비교하며 진행한다. 일단 첫 시작은 최소힙의 가장 앞에 있는 강의(시작시간이 가장 빠른 강의)의 종료시간을 집어넣고 시작한다. 그리고 시간간의 비교과정은 이 최소힙안에 들어있는 시간을 빼면서 진행된다.

만약 최소힙에서 막 뺀 이전 강의의 종료시간 보다 새로 가져온 강의의 시작시간이 더 작다면 강의시간이 겹쳐지므로 새로운 강의실이 더 필요할 것이다. 이때 새로가져온 강의의 종료시간을 최소힙에 넣는것 뿐만 아니라 비교시 사용했던 이전 강의의 종료시간도 같이 최소힙에 넣는다.

만약 새로 가져온 강의의 종료시간이 더 커서 겹쳐지지 않으면 한 강의실에서 같이 진행할 수 있는 것으로 이때는 비교시 사용했던 이전 강의의 종료시간을 다시 최소힙에 넣지 않고 새로 가져온 강의의 종료시간만 최소힙에 넣는다.

이런식으로 쭉 진행하면 결국 최소힙의 사이즈는 필요한 최소한의 강의실의 개수와 같아지게 되고 이 사이즈를 출력하면 답이된다.

### 왜 처음에 강의 시작 시간을 기준으로 오름차순 정렬을 해야 할까?
종료시간을 기준으로 오름차순을 하면 생길 수 있는 문제가 있다. 문제는 아래와 같다.

예를들어 시작시간이 한참 뒤에 있는 회의가 있는데, 그 회의가 종료시간이 짧다고 해서 앞으로 왔다 해보자. 그럼 그 회의는 앞에 진행된 회의중에서 종료시간이 가장 빠른 회의의 종료시간과 비교하고, 만약 그 종료시간보다 늦다면 그 회의로 합쳐질 것이다.

문제는 바로 여기에 있다. 종료시간이 일찍 끝나서 앞으로 왔지만, 정작 뒤에 시작시간이 더 빠른 회의가 뒤로 밀리고, 그 시작시간이 빠른 회의는 미래에 앞에 진행한 회의의 종료시간이랑 비교했을 때 겹쳐질 확률이 높아질 것이다. (즉, 강의실의 개수를 최소화하기가 불리해진다.)

왜냐하면 종료시간이 비교적 빠르지만 시작시간이 느린 회의가 이미 그 회의 뒤에 합쳐졌기 때문이다. 만약 이 시작시간이 느린 회의가 더 뒤에 있고, 시작시간이 빠른 회의를 먼저 합쳤다면 회의실의 개수가 늘어나는것을 좀 더 방지할 수 있을 것이다.

다른말로 말하자면 차라리 시작시간이 빠른 회의가 먼저 와서 비교후 합쳐졌다면, 앞에 회의랑 좀 더 밀집되게 합쳐질 수 있었는데, 종료시간이 빠르다고 앞에 온 회의 때문에, 그 다음 회의에 종료시간과 비교되면서 겹쳐지는 상황이 발생할 가능성이 높아진다.

따라서 중요한것은 회의 시작시간이 더 빠른것이 먼저 오도록 정렬해야 더 밀집되게 회의실을 배정 할 수 있다.


## 제출코드
```python
import sys
input = sys.stdin.readline
import heapq

n = int(input())
meeting = [tuple(map(int,input().split())) for i in range(n)]
meeting.sort(key=lambda x:x[0])

pq = [meeting[0][1]]

for m in meeting[1:]:
    p = heapq.heappop(pq)
    if p <= m[0]:
        heapq.heappush(pq,m[1])
    else:
        heapq.heappush(pq,p)
        heapq.heappush(pq,m[1])
print(len(pq))
```