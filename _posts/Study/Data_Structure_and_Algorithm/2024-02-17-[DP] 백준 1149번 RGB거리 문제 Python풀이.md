---
title: '[DP] 백준 1149번 RGB거리 문제 Python풀이'
author: baduk
date: 2024-02-17 17:43:00 +0900
categories: [Study, Data Structre and Algorithm]
tags: [study, python, problem solving, algorithm]
use_math: true
---
출처:
<https://www.acmicpc.net/problem/1149>

## 문제 간단소개
집이 N개가 있고, 각 집을 R,G,B 색으로 칠하려고 한다. R,G,B의 비용은 각 집마다 다르다. 서로 붙어있는 집은 같은 색깔로 칠하지 않으면서 색 칠할때 최소비용을 구하라.

## 문제 접근
나는 일단 문제를 처음 봤을 때, 브루트포스식으로 모든 경우를 탐색해서 해결하려고 하였다. 하지만 집의 개수인 N이 최대 1000으로 시간복잡도가 매우 크게 나올 것이라고 판단하여, 다른 방법을 고민하였다.

모든 경우를 트리형식으로 탐색하면 깊이가 1000인데 자식노드 두개씩 가지면서 내려가면 시간복잡도가 2의 천제곱이된다. 수가 너무 커서 시간초과 나올 것이다.

이 문제는 배열에서 앞에서 계산된 값을 쭉쭉 가져가면서 풀어나가는 방식인 다이나믹 프로그래밍으로 해결해야 한다.

## 문제 풀이
원리는 간단하다.

1번 집에서 색깔 R을 선택했을때, 2번집은 색깔 R을 선택하지 못하고, 색깔 G와 B를 선택해야한다. 따라서 1번집에서의 R의 비용을 가지고 2번집의 G,B에 각각 더한 값을 DP 테이블에 최소값이 들어가도록 업데이트한다.(이때는 아직 DP테이블에 업데이트 된것이 없으므로 그냥 넣어준다.)

1번 집에서 색깔 G를 선택했을때, 2번집은 색깔 G를 선택하지 못하고, 색깔 R과 B를 선택해야한다. 따라서 1번집에서의 G의 비용을 가지고 2번집의 R,B에 각각 더한 값을 DP 테이블에 최소값이 들어가도록 한다. 이때는 DP테이블에 B에 위치한 값은 1번집에서 R을 선택했을 때의 비용이 저장되어 있으므로, 최소값으로 업데이트 될 수 있도록 잘 처리해야한다.

1번 집에서 색깔 B를 선택했을때, 2번집은 색깔 B를 선택하지 못하고, 색깔 R,G만 선택해야한다. 따라서 1번집에서의 B의 비용을 가지고 2번집의 R,G에 각각 더한 값을 DP 테이블에 최소값이 들어가도록 업데이트한다.

이와 같은 방식으로 DP 테이블에 업데이트 된 값을 가지고, 이어서 3번 집, 4번 집, 5번 집, ... 에 대해 계산해나가면서 업데이트 시켜나가면 된다.

모든집을 최소값이 업데이트 되도록 누적시켜 더해가면서 계산하면, 맨 마지막 집에서 R,G,B 위치의 들어있는 값 중 가장 작은값이 모든집을 칠할때의 최소비용이 된다.

## 제출 코드
```python
import sys
input = sys.stdin.readline
n = int(input())
cost = [list(map(int,input().split())) for i in range(n)]
dp = [[0]*3 for i in range(n)]
dp[0] = cost[0]
for i in range(n-1):
    dp[i+1][1] = dp[i][0] + cost[i+1][1]
    dp[i+1][2] = dp[i][0] + cost[i+1][2]
    dp[i+1][0] = dp[i][1] + cost[i+1][0]
    dp[i+1][2] = min(dp[i+1][2], dp[i][1] + cost[i+1][2])
    dp[i+1][0] = min(dp[i+1][0], dp[i][2] + cost[i+1][0])
    dp[i+1][1] = min(dp[i+1][1], dp[i][2] + cost[i+1][1])
print(min(dp[-1]))
```

## 후기
코드가 좀 지저분해져서 디버깅이 조금 까다로웠다. 헷갈리지 않게 주의해야 할 것 같다.