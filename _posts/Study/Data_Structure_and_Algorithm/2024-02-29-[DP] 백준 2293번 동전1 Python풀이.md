---
title: '[DP] 백준 2293번 동전1 Python풀이'
author: baduk
date: 2024-02-29 12:43:00 +0900
categories: [Study, Data Structre and Algorithm]
tags: [study, python, problem solving, algorithm]
use_math: true
---
출처:
<https://www.acmicpc.net/problem/2293>

## 문제 간단소개
n가지 종류의 동전을 가지고 가치의 합을 k로 만들어 줄 때, 그 경우의 수를 구하라. 단, 순서만 다른 것은 같은 경우이다.

## 문제 접근
이 문제에서 주어진 테스트케이스에서는 동전의 종류는 1원 2원 5원짜리가 있고, 10원을 만들려고 한다. 이 때 1원, 2원, 5원을 적절히 뽑아서 10원을 만들어야 하는데, 중복조합을 이용해서 풀어보려고 하면 일단 최소 단위가 1원이니까, 이 최소단위인 1원으로 10원을 만드려면 최소 10개의 동전이 필요하다. 최대단위인 5원으로 10원을 만드려면 2개만 있으면 된다. 따라서 동전 최소2개~10개를 동전의 종류로부터 중복해서 뽑는 모든 경우의 수를 구하고, 그 경우의수 중 10이 되는 것을 골라내면 경우의 수를 구할 수 있다.

하지만 위와 같이 중복조합을 통해서 해결한다면 시간복잡도가 매우 커질 것이다. 그 이유는 코인의 종류는 최대 100개고, K원이라는 합을 만들때, K는 최대 10,000이다. 따라서 100가지의 종류에서 최대 10,000가지를 중복해서 뽑을때의 가짓수를 대략 계산해보면, 그 경우의 수가 상당히 커져 1억은 거뜬히 넘길 것이다.  

```
100 H 10000 = 10099 C 10000 

=> (10099 P 10000) / 10000!
```
식은 대략 위와 같을 것이다. 

따라서 이 문제는 DP로 풀어야 한다.

## DP식 세우기

DP식을 천천히 이해해 나가기 위해 식을 작게 세워나가보자. 이 문제에 대한 테스트 케이스에서의 동전의 종류는 1원, 2원, 5원으로 주어졌지만, 일단 1원만 있다고 생각해보자.

그리고 동전의 합이 0이 되는 경우의 수 , 1이 되는 경우의 수, 2가 되는 경우의 수, ... , k가 되는 경우의 수가 각각 담길 수 있도록 DP 테이블을 준비하고, 합이 0되는 경우의 수를 1로 채우고, 나머지는 0으로 채운다.

이때 동전의 합이 0이 되는 경우의 수를 1로 채우는 이유는 동전을 사용하지 않았을 때의 경우의 수 1을 뒤에 연산할 때 사용하려하기 때문이다.

처음에 1원짜리 동전만 있다고 했을 때 DP 테이블은 0부터 ~k가 되는 경우의 수는 모두 1로 채워질 것이다.

그 이유를 차근차근 알아보자. 먼저 1원짜리 동전으로 1원을 만드는 경우의 수를 업데이트 할 것이다. 이때는 0원이 되는 경우의 수 1과 1로 업데이트 되기 이전 값 0을 더한다. 그래서 경우의 수가 1이 나오는 것이다.

여기서 말하는 이전 값은 1이라는 동전이 들어가기 이전에 만들 수 있는 경우의 수이고, 물론 처음에 첫 동전을 가지고 진행할 때는 그 경우의 수가 0일 것이다. 그리고 0원에다가 1원을 더하면 1원이 만들어지므로, 1원이 들어왔을때 0원을 만드는 경우의 수를 그 값에다가 더한다.

좀 더 이해를 돕기 위해 예시를 하나 더 들어보겠다. 이번엔 1원 동전을 가지고 있는 상황에서 2원을 만드는 경우의 수를 구해보자. 이때도 마찬가지로 이전에 1원을 가지기 이전에 2원을 만들었던 동전의 경우의 수와 1원을 가지고 1원을 만든 경우의 수를 합하면 2원을 만드는 경우의 수 1이 나올 것이다.

## 제출코드

```python
import sys
input = sys.stdin.readline

n,k = map(int,input().split())
coin = [int(input()) for i in range(n)]
dp = [1]+[0]*k
for i in range(n):
    for j in range(coin[i],k+1):
        dp[j] = dp[j-coin[i]] + dp[j]
print(dp[k])
```