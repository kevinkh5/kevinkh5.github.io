---
title: '[Greedy] 백준 1202번 보석도둑(python)'
author: baduk
date: 2024-01-26 17:48:00 +0900
categories: [Study, Data Structre and Algorithm]
tags: [study, python, problem solving, algorithm]
use_math: true
---
## 문제 간단소개
도둑이 보석을 훔치려한다. 도둑은 최대 C무게를 담을 수 있는 K개 가방을 가지고 있고, 보석점에는 M무게와 V가격을 가진 보석이 N개있다. 이때 보석을 훔칠 수 있는 최대가격 구하라. (단 한 가방에 보석 하나만 넣을 수 있다.)

## 문제 접근
일단 단순하게 생각하면 가격이 비싼 보석을 최대한 많이 가방에 담아야 할 것이다. 문제는 가방에 무게제한이 있어서 무작정 많이 담을 수는 없다.

그렇다면 무작정 비싼 보석을 가방에다가 담는 것은 좋은 방법일까?
아래 상황을 한번 살펴보자.

```
보석A = (무게:70, 가격:100)
보석B = (무게:100, 가격:50)

가방A = 무게제한:100
가방B = 무게제한:70
```
예를들어 도둑이 위와 같은 상황이라고 가정하자. 현재 도둑은 가방A와 가방B를 가지고 있고, 훔칠 보석은 보석A와 보석B가 있다. 도둑이 만약 보석 A가 보석B보다 비싸다는 이유로 무작정 훔쳐서 생각없이 가방A에 넣어버리면, 보석B는 나머지 가방B에 무게 제한에 걸린다. 결국 보석 가격 100만큼 밖에 못 훔친다.

보석A를 가방 B에 담았다면, 보석B는 가방 A에도 담을 수 있으므로 최대 보석가격 150만큼 훔칠 수 있다. 후자의 방법이 훨씬 더 잘 훔쳤다고 볼 수 있다.

위 예시를 보면 알 수 있듯이, 일단 무게제한이 낮은 가방에 보석을 채워 넣는것이 중요하다. 가능한 무게제한이 낮은 가방에 보석을 먼저 넣는것이 다음 훔칠 보석에 대한 무게제한 확보에도 유리하니까.

다만 여러 보석들이 한 가방에 대해서 무게제한을 충족시킬 때, 그 중 가장 가격이 비싼 보석을 우선적으로 넣어주어야 한다. 그 이유는 먼저 가격이 싼 보석을 넣었다가 가격이 비싼 보석을 못넣게 되는 일이 발생하면 최대가격을 못구하게 되기 때문이다.

이와 같은 설명을 알고리즘을 활용하여 아래에서 풀어나가보자.

## 문제 풀이
일단 먼저 무게제한이 낮은 가방부터 보석을 채워야 하므로, 무게제한이 낮은 가방을 먼저 pop해서 뽑을 수 있도록 가방무게를 디센딩으로 정렬한다.

그리고 그 다음 pop해서 뽑은 가방에 채울 수 있는 보석들을 탐색해야 한다. 가방에 들어갈 수 있는 보석들을 모두 탐색하는 것은 자칫 높은 시간복잡도를 유발할 수 있다. 따라서 보석들도 무게를 기준으로 정렬해야 복잡도를 줄일 수 있다.

무게가 가장 낮은 보석이 인덱스 끝에 오도록 하기 위해 보석들도 무게를 기준으로 디센딩으로 정렬한다. 그리고 무게가 가장 작은 보석을 확인하기 위해 맨 끝 인덱스를 확인했는데, 가방에 넣을 수 없는 무게라면 리스트에 있는 나머지 보석들도 가방에 넣을 수 없으므로, 가방을 버리고 새로운 가방을 꺼낸다.

그리고 새로운 가방을 꺼냈고, 보석이 담긴 리스트에서 보석이 가방에 넣을 수 있는 무게면, 보석의 가격을 최대힙에 넣는다. 힙에 담을 수 있는 모든 보석(=무게제한에 걸리지 않는 보석)의 가격을 담았다면, 그 중 최대가격을 뽑아 sum_변수에 쌓아준다.

이와 같은 과정을 사용할 가방이 없어질 때까지 반복하면 sum_변수에는 훔칠 수 있는 최대가격이 저장되어 있을 것이다.

### 정리
```
1.가방의 무게가 작은것부터 팝할 수 있도록 디센딩정렬

2.물건의 무게가 작은것을 팝할 수 있도록 디센딩정렬

3.무게제한이 작은 가방을 먼저 꺼내서, 담을 수 있는 물건의 가격을 우선순위 큐에 담기.

4.물건의 무게가 무거워져 가방에 담을 수 없는 물건을 만나게되면, 반복문을 빠져나온다.
(뒤에는 볼 필요도 없이 무거워서 가방에 담을 수 없는 물건들만 남아있을 테니까)

5.우선순위 큐에서 가치가 가장 높은 물건의 가격을 팝하고 sum_에 합쳐준다.

5.다음 가방에 대해서 3~5번 과정을 반복한다.
```

## 제출코드

```python
import sys
input = sys.stdin.readline
import heapq

n, k = map(int,input().split())
jew = [tuple(map(int,input().split())) for i in range(n)]
bag = [int(input()) for i in range(k)]
jew = sorted(jew, key=lambda x:x[0], reverse=True)
bag = sorted(bag, reverse=True)
q = []
sum_ = 0
while bag:
    b = bag.pop()
    while jew and jew[-1][0] <= b:
        j = jew.pop()
        heapq.heappush(q,-j[1])
    if q:
        sum_ += -1*heapq.heappop(q)
print(sum_)
```